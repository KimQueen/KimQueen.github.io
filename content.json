{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Async/Await简介与用法","text":"简介 async/await是写异步代码的新方式，以前的方法有回调函数和Promise。 async/await是基于Promise实现的，它不能用于普通的回调函数。 async/await与Promise一样，是非阻塞的。 async/await使得异步代码看起来像同步代码，这正是它的魔力所在。 语法 我们看一下怎么使用promise和async和await来显示两段代码： Promise12345678const makeRequest = () =&gt;{ getJSON().then(data=&gt;{ console.log(data); return &apos;done&apos;; })}makeRequest() async/await123456const makeRequest = async () =&gt;{ console.log(await getJson()) return &quot;done&quot;;}makeRequest() 我们了解到async/await是根据Promise来进行封装的，现在我们现在看一下上面的两段代码的异同： 函数的内部多了一个async的关键字，await 关键字只能用在async定义的函数的内部。async函数会隐式的返回一个Promise，这个Promise的resolve值就是return的值（上面的例子中resolve值就是字符串“done”） 我们在看语法的时候发现我们不能再最外层的代码使用await，因为不在async函数中。 await getJSON()表示console.log会等到getJSON的promise成功reosolve之后再执行。对于async函数，返回的Promise对象，async函数内部return语句返回值的，会成为then方法回调函数的参数。 1234567async function f(){ return &apos;hello word&apos;;}f().then(v=&gt;{ console.log(v);// &quot;hello word&quot;}) async函数返回的Promise对象，必须等到内部所有的await命令后面的Promise对象执行完，才会发生变化，除非遇到return语句或是抛出错误，也就是说，只用async函数内部的异步操作都执行完成了，才会执行then方法指向的回调函数。对于async函数的内部函数的执行顺序： 其中对于async函数来说，其中任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。 1234async function f() { await Promise.reject(&apos;出错了&apos;); await Promise.resolve(&apos;hello world&apos;); // 不会执行} 上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。做个是async函数的特性，但是有的时候我们期望前一个异步操作失败，也不要中断第二个异步的操作，这样的话我们可以在第一个wait放在try …catch结构中，这样的话不管这个异步操作是否成功，第二个await都会执行。 1234567891011async function f() { try { await Promise.reject(&apos;出错了&apos;); } catch(e) { } return await Promise.resolve(&apos;hello world&apos;);}f().then(v =&gt; console.log(v))// hello world 第二种方法就是对第一个await再一次添加一个catch方法，处理前面的错误： 12345678910async function f() { await Promise.reject(&apos;出错了&apos;) .catch(e =&gt; console.log(e)); return await Promise.resolve(&apos;hello world&apos;);}f().then(v =&gt; console.log(v))// 出错了// hello world 对错误进行处理1.Async/Await让try/catch可以同时处理同步和异步错误。在下面的promise示例中，try/catch不能处理JSON.parse的错误，因为它在Promise中。我们需要使用.catch，这样错误处理代码非常冗余。并且，在我们的实际生产代码会更加复杂。 12345678910111213141516const makeRequest = () =&gt; { try { getJSON() .then(result =&gt; { // JSON.parse可能会出错 const data = JSON.parse(result) console.log(data) }) // 取消注释，处理异步代码的错误 // .catch((err) =&gt; { // console.log(err) // }) } catch (err) { console.log(err) }} 使用aync/await的话，catch能处理JSON.parse错误 123456789const makeRequest = async () =&gt; { try { // this parse may fail const data = JSON.parse(await getJSON()) console.log(data) } catch (err) { console.log(err) }} 对于条件语句的可读性增强123456789101112131415const makeRequest = () =&gt; { return getJSON() .then(data =&gt; { if (data.needsAnotherRequest) { return makeAnotherRequest(data) .then(moreData =&gt; { console.log(moreData) return moreData }) } else { console.log(data) return data } })} 使用async/await编写可以大大地提高可读性: 1234567891011const makeRequest = async () =&gt; { const data = await getJSON() if (data.needsAnotherRequest) { const moreData = await makeAnotherRequest(data); console.log(moreData) return moreData } else { console.log(data) return data }} 中间值我们现在有一个需求是这样的，调用promise1返回结果去调用promise2，然后再使用二者的结果去调用promise3.这样的话 我们的代码可能是这样的： 123456789const makeRequest = () =&gt; { return promise1() .then(value1 =&gt; { return promise2(value1) .then(value2 =&gt; { return promise3(value1, value2) }) })} 如果promise3不需要value1，可以很简单地将promise嵌套铺平。如果你忍受不了嵌套，你可以将value 1 &amp; 2 放进Promise.all来避免深层嵌套 123456789const makeRequest = () =&gt; { return promise1() .then(value1 =&gt; { return Promise.all([value1, promise2(value1)]) }) .then(([value1, value2]) =&gt; { return promise3(value1, value2) })} 但是这样的做法是为了可读性牺牲了语义，处理避免嵌套，没有任何必要将value1和value2放在一个数组里面使用async和await进行编写的话 12345const makeRequest = async () =&gt; { const value1 = await promise1() const value2 = await promise2(value1) return promise3(value1, value2)} 错误栈函数a内部运行了一个异步任务b()。当b()运行的时候，函数a()不会中断，而是继续执行。等到b()运行结束，可能a()早就运行结束了，b()所在的上下文环境已经消失了。如果b()或c()报错，错误堆栈将不包括a() 123const a = () =&gt; { b().then(() =&gt; c());}; 现在将这个例子改成async函数。 1234const a = async () =&gt; { await b(); c();}; b()运行的时候，a()是暂停执行，上下文环境都保存着。一旦b()或c()报错，错误堆栈将包括a()。","link":"/2020/11/01/Async-Await简介与用法/"},{"title":"CSRF攻击方式","text":"CSRF 是什么？CSRF（Cross-site request forgery），中文名称：跨域请求伪造。 CSRF 可以做什么？你这可以这么理解 CSRF 攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 CSRF 的原理我们下面根据一个时序图来模拟一下这样的思想： 从上面的图中我们可以看出，要完成一次CSRF的攻击，受害者必须要完成两个步骤： 1.登录受信任的网站A，并在本地生成了cookie 2.在不登出A的情况下，访问危险网站B但是我们看到了，如果我们：”不满足上面的两个条件的一个，就不会受到CSRF的攻击”。是的，就是这样的，但是我们不能保证下面的情况不会发生。 1.我们不能保证我们登录一个网站之后，不再打开tab页面访问另外的一个网站。 2.不能保证关闭浏览器之后，本地的cookie马上过期，我上次的会话已经过期（事实上，关闭浏览器并不意味着结束了一个会话，但大多数人都会认为关闭浏览器等于退出\\结束一个会话）。 3.上面的攻击一个网站，可能是一个存在其他漏掉的可信任的被人经常访问的网站。 示例 1银行网站 A，它以 GET 请求来完成银行，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000而对于危险的网站，它里面有一段 HTML 的代码如下： 1 &lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 我们看一下，首先我们登录银行网站A，然后访问了危险网站B，这个时候我们发现我们的银行账户里面的钱少了 1000 元。我们看一下原因：因为银行A网站违反了HTTP规范，使用了GET请求，请求了更新资源，在访问危险网站B之前，我们已经登录了A网站，而B的&lt;img&gt;用GET的方式请求了第三方的资源(这里的第三方资源就是指的是银行网站，原来一个十分合法的请求，被不合法的利用了)，所以我们的浏览器就会带上在网站A的 Cookie 发出的 Get 请求，去获取资源(“http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000.“)然后银行资源获取到请求之后，认为这是一个更新资源的操作，所以就转账了，钱飞了~ 示例 2为了杜绝上面的问题，采取了POST的凡是进行转账的操作比如说银行网站A的web表单如下： 12345&lt;form action=&quot;Transfer.php&quot; method=&quot;POST&quot;&gt; &lt;p&gt;ToBankId: &lt;input type=&quot;text&quot; name=&quot;toBankId&quot; /&gt;&lt;/p&gt; &lt;p&gt;Money: &lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Transfer&quot; /&gt;&lt;/p&gt;&lt;/form&gt; 后台处理页面Transfer.php如下： 1234567&lt;?php session_start(); if (isset($_REQUEST[&apos;toBankId&apos;] &amp;&amp; isset($_REQUEST[&apos;money&apos;])) { buy_stocks($_REQUEST[&apos;toBankId&apos;], $_REQUEST[&apos;money&apos;]); }?&gt; 危险网站B，仍然只是包含那句HTML代码： 1 &lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 首先我们登录银行网站A，然后访问了危险网站B，这个时候我们发现我们的银行账户里面的钱又少了 1000 元。这次事故的原因是：银行的后台系统使用了$_REQUEST来获取请求的的数据，然而$_REQUEST既可以获取 GET 请求的数据，也可以获取 POST 请求的数据，这样就造成了后台处理程序没有办法分辨到底是GET请求还是POST请求，在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。 示例 3经过前面 2 个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下： 1234567&lt;?php session_start(); if (isset($_POST[&apos;toBankId&apos;] &amp;&amp; isset($_POST[&apos;money&apos;])) { buy_stocks($_POST[&apos;toBankId&apos;], $_POST[&apos;money&apos;]); }?&gt; 然而，危险网站B与时俱进，它改了一下代码: 1234567891011121314151617181920&lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function steal() { iframe = document.frames[&quot;steal&quot;]; iframe.document.Submit(&quot;transfer&quot;); } &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;steal()&quot;&gt; &lt;iframe name=&quot;steal&quot; display=&quot;none&quot;&gt; &lt;form method=&quot;POST&quot; name=&quot;transfer&quot; action=&quot;http://www.myBank.com/Transfer.php&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;toBankId&quot; value=&quot;11&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot;&gt; &lt;/form&gt; &lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 如果用户仍是继续上面的操作，很不幸，结果将会是再次不见 1000 块……因为这里危险网站B暗地里发送了 POST 请求到银行! 总结一下上面 3 个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一个&lt;img&gt;就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了CSRF攻击，后果都有可能很严重。 理解上面的 3 种攻击模式，其实可以看出,CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！ CSRF 的防御机制根据看到的资料，CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。服务端的CSRF方式方法由很多中，但是思想都是一样的，就是在客户端增加伪随机数(1)Cookie Hashing(所有的表单都包含同一个伪随机值)这个方法虽然简陋，但是很有效，因为攻击者不能获取第三方的Cookie（理论上），所以表单数据也就构造失败了。 12345 &lt;?php //构造加密的Cookie信息 $value = “DefenseSCRF”; setcookie(”cookie”, $value, time()+3600); ?&gt; 在表单里增加Hash值，以认证这确实是用户发送的请求。 123456789 &lt;?php $hash = md5($_COOKIE[&apos;cookie&apos;]); ?&gt; &lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt; &lt;/form&gt; 然后在服务器端进行Hash值验证: 123456789101112&lt;?php if(isset($_POST[&apos;check&apos;])) { $hash = md5($_COOKIE[&apos;cookie&apos;]); if($_POST[&apos;check&apos;] == $hash) { doJob(); } else { //... } } else { //... } ?&gt; 这个方法大概已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。(2)验证码这个方案的实例是：每一次的用户提交都需要用户在表单上填写一个验证码，这个方案可以完全的解决CSRF，但是在用户体现上不交差，而且还会产生一些被称为MHTML的Bug(3).One-Time Tokens(不同的表单包含一个不同的伪随机值)在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。可以添加当前时间的时间戳或是随机数字。盗一段代码： 先是令牌生成函数(gen_token()): 1234567&lt;?php function gen_token() { //这里我是贪方便，实际上单使用Rand()得出的随机数作为令牌，也是不安全的。 //这个可以参考我写的Findbugs笔记中的《Random object created and used only once》 $token = md5(uniqid(rand(), true)); return $token; } 然后是 Session 令牌生成函数(gen_stoken()) 123456789101112&lt;?php function gen_stoken() { $pToken = &quot;&quot;; if($_SESSION[STOKEN_NAME] == $pToken){ //没有值，赋新值 $_SESSION[STOKEN_NAME] = gen_token(); } else{ //继续使用旧的值 } } ?&gt; WEB表单生成隐藏输入域的函数 1234567&lt;?php function gen_input() { gen_stoken(); echo “&lt;input type=\\”hidden\\” name=\\”&quot; . FTOKEN_NAME . “\\” value=\\”&quot; . $_SESSION[STOKEN_NAME] . “\\”&gt; “; } ?&gt; WEB表单结构 12345678910&lt;?php session_start(); include(”functions.php”); ?&gt; &lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;? gen_input(); ?&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt; &lt;/FORM&gt; 5).服务端核对令牌：这个很简单，这里就不再啰嗦了。这篇文章还不错","link":"/2020/11/01/CSRF攻击方式/"},{"title":"原生函数","text":"原生函数： String() Number() Boolean() Array() Object() Function() RegExp() Date() Error() Symbol() – 在ES6中新加入的 12var s = new String(\"hello word\");console.log(s.toString()); // hello word 一般情况下我们是不直接使用封装对象，最好的办法是让JavaScript引擎自己决定什么时候使用封装对象，也就是说我们首先考虑的是’abc’和42这样的基本类型，而不是new String(“abc”)和new Number(42) 原生函数作为构造函数的时候对于数组(array)、对象(object)、函数(function)和正则表达式，我们通常喜欢以字面量的形式来创建它们。实际上，使用字面量和使用构造函数的效果是一样的(创建的值都是通过封装对象来包装的) Array(..)1234var a = new Array(1,2,3);a; // [1,2,3]var b = [1,2,3];b; // [1,2,3] ps:Array(..)和new Array的效果是一样的，如果不带有new，它会进行自动的补全。也就是说Array(1,2,3)和new Array(1,2,3)的效果是一样的。 永远都不要使用空单元数组。 Object(..) Function(..) 和RegExp(..) 和上面的数组一样，如果不是万不得已，尽量不要使用Object(..)/Function(..)/RegExp(..) 其中 new Object()来创建对象，因为这样就没有办法像使用常量的形式那样一次设定了多个属性，而是必须要逐一设定。 构造函数Function只有在极少数的情况下很有用，比如动态定义函数参数和函数体的时候，如果不是将Function(..)当做eval(..)的替代品，基本上是不会通过这样的方式来定义函数的。 建议使用常量的形式(如 /^a*b+/9)来定义正则表达式，这样的话，不仅语法简单，而且执行的效率也会更加的高，因为JavaScript引擎在代码执行前会对它们进行预编译和缓存，与前面的构造函数不同，RegExp(..)有时候还是很有用的，比如说动态的定义正则表达式的时候： 1234var name = 'kim'var namePattern = new RegExp(\"\\\\b(?:\"+name+\")+\\\\b\",'ig');var match = someText.match(namePattern); Date(..) 和Error（..）相对于其他的原生的构造函数，Date(..)和Error(..)的用处要大的多，因为没有对应的常量作为它们的替代。创建日期对象必须要使用new Date()。Date(..)可以带有参数，用来指定日期和事件，但是不带参数的话，就要使用当前的日期和事件。 构造函数Error(..)带还是不带new关键字都是可以的。 创建错误对象(error object) 主要是为了获取当前运行栈的上下文，栈上下文信息包括函数调用栈信息和产生错误的代码行号，为了方便调试。具体的使用就不详细阐述了。 Symbol(..)我们可以使用Symbol(..)原生构造函数来自定义符号，但是它比较特殊，是不能带有new的关键字的，否则的话，就会报错。 原生原型原生的构造函数都有自己的.prototype对象。这些对象包含其对子类型所特有的行为特征。 在相关文档中，我们约定将String.prototype,xyz可以简写成String#xyz,对其他的.prototype也是一样的。","link":"/2020/11/01/JavaScript的原生函数/"},{"title":"JavaScript的数组","text":"使用数组的目的：数组用来存储一系列同一种数据类型的值。但是在JavaScript中我们可以存储不同类型的值。 创建和初始化数组12345678910111213//三种声明数组的方式，使用new的方式进行声明let dayOfWeek = new Array();let dayOfWeek = new Array(7);let dayOfWeek = new Array(&apos;Sunday&apos;,&apos;Monday&apos;,&apos;Tuseday&apos;,&apos;Wednesday&apos;,&apos;Thursday&apos;,&apos;Friday&apos;,&apos;Saturday&apos;);// 两种声明数组的方式，使用[]的方式进行声明let dayOfWeek = [];let dayOfWeek =[&apos;Sunday&apos;,&apos;Monday&apos;,&apos;Tuseday&apos;,&apos;Wednesday&apos;,&apos;Thursday&apos;,&apos;Friday&apos;,&apos;Saturday&apos;];//数组可以使用length描述数组的长度console.log(dayOfWeek.length); // 输出：7 添加元素从数组中添加和删除元素也是很容易的，但有时也会很棘手，假设我们有一个数组的numbers，初始化成0到9： 1let numbers = [0,1,2,3,4,5,6,7,8,9]; 如果想要给数组添加一个元素(比如说10)，只要把值赋给数组中最后一个空位上的元素即可。 1numbers[numbers.length] = 10; 使用push方法可以使用push的方法，能把元素添加到数组的末尾。通过push方法，能添加任意个元素: 12numbers.push(11);numbers.push(12,13); 输出的结果是0,1,2,3,4,5,6,7,8,9,10,11,12,13 插入元素到数组的首位（传统方法）如果我们想要想数组的最前面插入一个值，而不是像之前一样插入到后面，为了实现这个需求，我们首先要腾出数组第一位的位置，把所有元素的位置向右移动一位，我们可以循环数组中的元素，从最后我们把值赋值到第一位上面，下面具体讲一下具体实现的逻辑： 1234for(let i = numbers.length ; i &gt;= 0; i--){ numbers[i] = number[i-1];}numbers[0] = -1; 使用unshift方法在JavaScript中，数组中有一个方法叫做unshift，可以直接将数值插入到数组的首部： 12numbers.unshift(-2);numbers.unshift(-4,-3); 输出的结果为[-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]。 删除元素如果我们要删除数组中最后的一个元素，我们可以使用pop方法来进行操作,具体的调用的方法就是： 1numbers.pop(); 从数组的首位删除元素（传统方法）如果我们想要从数组的第一个元素，可以使用下面的代码： 123for(let i = 0 ; i &lt; numbers.length; i++){ numbers[i] = number[i+1];} 使用shift方法如果想要删除数组的第一个元素，可以使用shift方法来实现： 1numbers.shift(); 在任意的位置添加和删除元素我们可以使用splice方法，简单的通过指定位置/索引，就可以删除相应位置和数量的元素： 1numbers.splice(5,3); 这行代码的意思就是从数组索引5开始的3个元素，也就意味着numbers[5],numbers[6],numbers[7]从数组中删除。如果我们想把数字2,3,4插入到数组里，放在之前删除的位置上面，我们可以再一次使用splice方法: 1numbers.splice(5,0,2,3,4); 那我们介绍一下splice各个参数的意义：splice的第一个参数，表示想要删除或是插入元素的索引值。第二个参数是删除的元素的个数，第三个参数往后，就是要添加到数组里的值。 二维和多维数组如果我们想要记录数天每小时的气温，我们使用数组来保存这些数据，我们应该怎么记录，我们可以这样记录： 12var averageTempDay1 = [72,75,79,81,81,80];var averageTempDay1 = [81,79,75,75,73,72]; 但是这不是最好的方法，我们可以做到的更好，我们可以使用矩阵(二维矩阵)来存储这些信息，矩阵的行保存每一天的数据，列对应小时级别的数据： 123let averageTemp = [];averageTemp[0] = [72,75,79,81,81,80];averageTemp[1] = [81,79,75,75,73,72]; JavaScript只支持一维数组，并不支持矩阵。但是，我们可以像上面的代码一样，用数组的嵌套来实现一维或是多维数组，代码也可以这样写： 1234567891011121314151617let averageTemp = [];// day 1averageTemp[0] = [];averageTemp[0][0] =72;averageTemp[0][1] =75;averageTemp[0][2] =79;averageTemp[0][3] =81;averageTemp[0][4] =81;averageTemp[0][5] =80;// day 2averageTemp[1] = [];averageTemp[1][0] =81;averageTemp[1][1] =79;averageTemp[1][2] =75;averageTemp[1][3] =75;averageTemp[1][4] =73;averageTemp[1][5] =72; 迭代二维数组的元素如果我们想看一个二维数组的输出，我们可以创建一个通用的函数，专门输出里面的值： 1234567function printMatrix(myMarix){ for(let i = 0; i&lt; myMarix.length; i++){ for(let j = 0; j &lt; myMarix[i].length; j++){ console.log(myMarix[i][j]); } }} 多维数组假如我们需要创建一个3X3X3的矩阵，每一格里包含矩阵的i（行）j（列）以及z（深度）之和： 12345678910let matrix3x3x3 = [];for(let i =0; i &lt; 3; i++){ matrix3x3x3[i] = []; for(let j =0; j &lt; 3; j++){ matrix3x3x3[i][j] = []; for(let z =0; z &lt; 3; z++){ matrix3x3x3[i][j][z] = i + j + z; } }} 我们如果要遍历这个三维数组的话，我们具体的操作如下： 1234567for(let i =0; i &lt; matrix3x3x3.length; i++){ for(let j =0; j &lt; matrix3x3x3[i].length; j++){ for(let z =0; z &lt;matrix3x3x3[i][j].length; z++){ matrix3x3x3[i][j][z] = i + j + z; } }} JavaScript的数组方法参考数组合并我们设想一下下面的场景：有多个数组，需要合并起来变成一个数组，我们可以迭代各个数组，然后把每一个元素加入最终的数组，现在JavaScript已经为我们提供了方法，叫做concat方法： 1234let zero = 0;let positiveNumbers = [1,2,3];let negativeNumbers = [-3,-2,-1];let numbers = negativeNumbers .concat(zero,positiveNumbers ) 上面的数组里面的数是从-3到3，在这个例子里面，zero将被合并发哦negativeNumbers数组的后面，然后positiveNumbers 也将会被合并到已经合并了zero的negativeNumbers数组里面。 迭代器函数加入有一个数组，他的值是从1到15，如果数组中的元素可以被2整除（偶数），函数返回true，否则就要返回false。 12345let isEven = function(x){ console.log(x); return (x % 2 == 0) ? true :false;}let numbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]; 1.使用every方法进行迭代every方法会迭代数组中的每一个元素，直到返回false。 1numbers.every(isEven) 这个例子里面，数组的第一个元素是1，不是2 的倍数，因此isEven函数返回false，然后every就执行结束了。2.用some方法进行迭代它和every的行为类似，不过some方法会迭代数组的每一个元素，直到函数返回true。 1numbers.some(isEvent) 在我们的例子中，numbers数组的第一个偶数是2(第二个元素)，第一个被迭代的元素是1，isEven会返回false，第二个被迭代的元素是2，isEven返回true，isEven返回true– 迭代结束。3.forEach方法迭代如果要迭代整个数组的话，可以使用forEach方法，它和使用for循环的结果是一样的： 123numbers.forEach (function(x){ console.log((x%2 == 0))；})； 4.使用map和filter方法JavaScript还有两个会返回新数组的遍历方法，第一个是map： 1let myMap = numbers.map(isEven); 现在数组myMap里面的值是[false,true,false,true,false,true,false,true,false,true,false,true,false,true,false]。这个数组保存的是传入map方法的isEven函数的运行结果，这样就很好的判断一个元素是不是偶数，myMap[0]是false，所以myMap[0]不是偶数，myMap[1]是true，因此myMap[1]是偶数。5.使用reduce方法reduce方法接受一个函数作为参数，这个函数有4个参数：previuosValue，currentValue，index和array。这个函数会返回一个将叠加到累加器的值。reduce方法停止执行后会返回这个累加器。如果要对一个数组中的所有元素求和，这就很有用： 123numbers.reduce(function (previous,current,index){ return previous + current;}) ECMAScript 6和数组的新功能1.使用forEach和箭头函数迭代箭头函数可以简化使用forEach迭代数组元素的做法，我们给出例子如下： 12345678numbers.forEach(function (x){ console.log( x % 2 === 0);})// 进行代码的简化numbers.forEach( x =&gt;{ console.log( x % 2 === 0);}) 2.使用for...of循环 123for(let n of numbers){ console.log( (n%2 == 0 ) ? &apos;even&apos; : &apos;odd&apos;);} 3.使用ES6新的迭代器(@@iterator) ES6还为Array类增加了一个@@iterator属性，需要通过symbol.iterator来访问。代码如下： 123456let iterator = numbers[Symobol.iterator]();console.log(iterator.next().value); //1console.log(iterator.next().value); //2console.log(iterator.next().value); //3console.log(iterator.next().value); //4console.log(iterator.next().value); //5 只要不断的调用迭代器的next方法，就能一次得到数组中的值。numbers数组中有15个值，因此需要调用15次iterator.next().value。数组中的所有值都迭代完之后，iterator.next().value会返回undefined。 数组的entries、key和values 我们先来看一下entries方法，entries方法返回包含键值对的@@iterator，下面我们对这个方法进行演示：1234let aEntries = numbers.entries(); //得到键值对的迭代器console.log(aEntries .next().value); //[0,1] - 位置0的值为1console.log(aEntries .next().value); //[1,2] - 位置1的值为2console.log(aEntries .next().value); //[2,3] - 位置2的值为3 在numbers数组中都是数字，key对应数组中的位置，value是保存在数组索引的值。 keys方法返回包含数组索引的@@iterator，下面我们对这个方法进行演示：1234let akeys = numbers.keys();console.log(akeys.next()); //{value:0,done:false}console.log(akeys.next()); //{value:1,done:false}console.log(akeys.next()); //{value:2 ,done:false} keys方法会返回numbers数组的所以，一旦没有可迭代akeys.next()就会返回一个value属性为undefined，done属性为true的对象。如果done属性的值为false，就意味着还有可以迭代的值。 values方法返回@@iterator则包含数组的值，使用这个方法的代码示例如下：1234let aValues = numbers.values();console.log(aValues .next()); //{value:1,done:false}console.log(aValues .next()); //{value:2,done:false}console.log(aValues .next()); //{value:3 ,done:false} 4.使用from方法Array.from方法根据已有的数组创建一个新的数组，比如，要复制numbers数组，可以这么做： 123let numbers = Array.from (numbers);// 还可以传入一个过滤函数let evens = Array.from (numbers, x=&gt;(x % 2 == 0)); 5.使用Array.of方法Array.of方法根据传入的参数创建一个新的数组，以下面的数组为例： 123456789let numbers3 = Array.of(1);let numbers4 = Array.of(1,2,3,4,5,6,7);//代码等效于let numbers3 = [1];let numbers4 =[1,2,3,4,5,6,7];// 我们也可以根据这个方法赋值已有的数组let numbersCopy = Array.of(...numbers4); 6.使用fill方法fill方法用静态值来进行数组的填充，下面的代码为例： 1234let numbersCopy = Array.of(1,2,3,4,5,6,7);numbersCopy.fill(0); // [0,0,0,0,0,0,0]numbersCopy.fill(2,1); // [0,2,2,2,2,2,2]numbersCopy.fill(1,3,6); // [0,2,2,1,1,1,2] 7.使用copyWithin方法copyWithin方法复制数组中的一系列元素到同一数组指定的起始位置。 12345let numbers4 =[1,2,3,4,5,6];numbers4.copyWithin(0,3) // 把4.5.6三个值复制到数组的前三个位置let numbers5 =[1,2,3,4,5,6];numbers5.copyWithin(1,3,5) //把4.5.6三个值复制到数组的1,2两个位置上 排序元素-reverse()reverse方法让元素中的数组反序. 123let numbers = [1,2,3,4,5,6];numbers.reverse(); // [6,5,4,3,2,1]numbers.sort() //[1,2,3,4,5,6]; 自定义排序我们可以对任何对象类型的数组进行排序，也可以创建compareFunction来比较元素。例如对象Person有名字和年龄属性，我们希望可以按照年龄进行排序。 123456789101112131415let persons = [ {name:&apos;John&apos;,age:30}, {name:&apos;Ana&apos;,age:20}, {name:&apos;Chris&apos;,age:25},];function compareFunction(a,b){ if(a.age &lt; b.age){ return -1; } if(a.age &gt; b.age){ return 1; } return 0;}console.log(persons.sort(compareFunction)); 字符串排序123let names = [&apos;Ana&apos;,&apos;ana&apos;,&apos;john&apos;,&apos;John&apos;];console.log(names.sort());//输出： Ana John ana john 输出上面的情况是因为支付串的排名是按照ASCII值来进行排序的。现在如果我们输入一个忽略大小写的比较函数： 123456789name.sort(function(a,b){ if(a.toLowerCase() &lt; b.toLowerCase()){ return -1; } if(a.toLowerCase() &gt; b.toLowerCase()){ return 1; } return 0;}) 搜索 搜索有两个方法：indexOf方法返回与参数匹配的第一个元素的索引，lastIndexOf返回与参数匹配的最后一个元素的索引。 在ECMAScript6新增了方法– find和findIndex方法 123456let numbers =[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];function multipleOf13(element,index,array){ return (element % 13 == 0) ? true :false;}console.log(numbers.find(multipleOf13)); // 返回第一个满足条件的值console.log(numbers.findIndex(multipleOf13));//返回第一个满足条件的值的索引 ECMAScript7中又议案家了includes方法这个方法的使用方式是如果数组中存在某个元素，includes方法会直接返回true，否则就会返回false，现在我们通过一段代码进行具体的阐述： 1234console.log(numbers.includes(15)); // truelet numbers = [7,6,5,4,3,2,1];// 因为查找是从数组的索引为5之后开始的，所以没有4console.log(numbers.includes(4,5)); // false","link":"/2020/11/01/JavaScript的数组/"},{"title":"JavaScript的栈","text":"栈数据结构栈是一种遵从后进先出（LIFO）原则的有序集合。新增加的或删除的元素都保存在栈的同一端，称作栈顶，另外的一端就是栈底。在栈里面，新元素都靠近栈顶，旧元素都接近栈底。 创建栈我们将创建一个类来标识栈。让我们从基础开始，先声明这个类： 123function Stack(){ //各种属性和方法的声明} 首先，我们需要一种数据结构来保存栈的元素，可以选择数组： 1let items = []; 接下来，我们要为我们的栈声明一些方法。 push(element(s)):添加一个（或几个）新元素到栈顶。 pop():移除栈顶的元素，同时返回被移除的元素。 peek():返回栈顶的元素，不对栈做任何的修改（这个方法不会移除栈顶的元素，仅仅是返回它） isEmpty():如果栈里没有任何元素都返回true，否则返回false。 clear():移除栈里的所有元素 size():返回栈里的元素个数，这个方法和数组的length属性很类似。向栈添加元素我们要先实现第一个方法push，这个方法负责往栈里添加新元素，有一点很重要：该方法只添加元素到栈顶，也就是栈的末尾。push方法可以这样写：123this.push = function (element){ item.push(element);} 因为我们使用了数组还是保存栈里的元素，所以可以用上一章学到了push方法来实现。 从栈移除元素接下来，我们来实现pop方法。这个方法只要用来移除栈中的元素。栈遵从LIFO原则，因此移出的是最后添加进去的元素。因此，我们可以用上一章讲数组时介绍的pop方法。栈的pop方法可以这样写： 123this.pop = function(){ return items.pop();} 只能用push和pop方法添加和删除栈中的元素，这样一来，我们的栈自然就遵从了LIFO原则。 查看栈顶元素现在我们的类实现一些额外的辅助方法，如果想知道栈里最后添加的元素是什么，可以用peek方法，这个方法将返回栈顶的元素： 123this.peek = function(){ return items[items.length - 1];} 如上图中，有一个包含三个元素的栈，因此内部数组的长度就是3.数组中最后一项的位数是2，length-1 （3-1）正是2。 检测栈是否为空下一步我们来实现isEmpty，如果栈为空的话讲返回true，否则就返回false： 123this.isEmpty = function (){ return items.length == 0;} 使用isEmpty方法，我们能简单的判断内部数组的长度是否为0. 那么下面我们来看一下size方法： 123this.size = function (){ return items.length;} 清空和打印栈元素最后，我们来实现clear方法。clear方法用来移除栈中的所有元素，把栈清空。实现最简单的方式是： 123this.clear = function (){ items = [];} 另外我们可以多调用pop方法，把数组中的元素全部移除，这样也能实现clear方法。完成了！栈已经实现，通过一个例子来放松一下：为了检查栈里的内容，我们开实现一个辅助方法，交print。他会把栈里的元素输出到控制台： 123this.print = function (){ console.log(items.toString());} 使用Stack类在深入了解栈的应用前，我们先来学习如何使用Stack类。首先，我们需要初始化Stack类。然后，验证一下栈是否为空（输出true，因为还没有往栈里添加元素） 1234567891011121314151617let stack = new Stack();console.log(stack.isEmpty()); // 输出为true// 向栈中添加元素stack.push(5);stack.push(8);//查看栈顶元素console.log(stack.peek()); //输出 8//再添加一个元素stack.push(11);console.log(stack.size()); // 输出 3console.log(stack.isEmpty()); //输出false//再添加一个元素stack.push(15); 现在我们直观的看一下我们对栈的操作，以及栈的当前状态： 然后调用两次pop函数来移除2个元素： 1234stack.pop();stack.pop();console.log(stack.size()); // 输出2stack.print(); // 输出[5,8] 现在我们直观的看一下我们对栈的操作，以及栈的当前状态： ECMAScript 6 和stack类我们花时间分析一下代码，看看是都能用ECMAScript6（ES6）的新功能来改进。我们创建一个可以当做类来使用Stack函数。JavaScript函数都有构造函数，可以用来模拟类的行为。我们生命了一个私有的items变量，它只能被Stack函数/类访问。然而，这个方法为每个类的实例都创建一个items变量的副本。因此，如果要创建多个Stack实例，它就不太适合了。 用ES6 语法声明Stack类我们看一下下面的代码： 123456789class Stack { constructor(){ this.item = []; //{1} } push(element){ this.items.push(element); } //其他方法} 我们只是用ES6的简化语法那Stack函数转化成Stack类。这种方法不能像其他语言（Java，C++，C#）一样直接在类里面声明变量，只能在类的构造函数constructor里声明在类的其他函数里用this.nameofVariable就可任意引用这个变量。尽管代码看起来更简洁，更漂亮，变量items却是公共的。ES6的类是基于原型的。虽然基本原型的类比基本函数的类更节省内存，也更适合创造多个实例，却不能够声明私有属性（变量）或方法。而且，在这个情况下，我们希望Stack类的用户只能访问暴露给类的方法。否则，就有可能从栈的中间移除元素，这不是我们希望看到的。看一下ES6的限定作用域Symbol实现类1.用ES6的限定作用域Symbol实现类ES6增加了一种叫做symbol的基本类型，它是不可变的，可以用作对象的属性，看看怎么用它来在Stack类中声明items属性： 1234567let _item = Symbol(); //(1)class Stack { constructor (){ this[_items] = []; // (2) } // Stack 方法} 在上面的代码中，我们声明了Symbol类型的变量_items（行1），在类的constructor函数中初始化它的值（行2）。要访问_items,只需把所有的this.items都换成this[_items]。 这种方法创建了一个私有属性，因为ES6新增的Object.getOwnPropertySymbol方法能够取到类里面声明的所有Symbol属性，下面是一个破坏Stack类的例子： 123456789let stack = new Stack();stack.push(5);stack.push(8);let objectSymbols = Object.getOwnPropertySymbols(stack);console.log(objectSymbols.length); //1console.log(objectSymbols); //[Symbol()]console.log(objectSymbols[0]); //Symbol()console.log(objectSymbols[0].push(1));stack.print(); // 输出：5,8,1 上面的代码我们可以看到，访问stack[objectSymbols[0]]是可以得到_items.并且，_items属性是一个数组，可以进行任何的数组操作，比如从中间删除或是添加元素。我们操作的是栈，不应该出现这样的操作。2.ES6是的weakMap有一种数据类型可以确保属性是私有的，这就是WeakMap。我们会在以后深入探讨Map这种数据结构，现在只需要知道weakMap可以用来存储键值对，其中键是对象，值可以是任意数据类型。如果用weakMap来存储items变量，stack就是这样的： 123456789101112131415const items = new weakMap(); //声明一个weakMap类型的变量itemsclass Stack{ constructor(){ items.set(this, []); //以this为键，把代表栈的数组存入items } push(element){ let s = items.get(this); //从weekMap中取出值 s.push(element) } pop(){ let s = items.get(this); let r = s.pop(); return r; }} 在上面的代码中，items在stack类是真正的私有属性，但是还有一件事要去做。items现在仍然是在Stack类以外声明的，因此谁都可以来修改Stack这个类，这个时候我们需要一个闭包(外层函数)把Stack类包起来没这样就只能在这个函数里访问weakMap(). 123456789let Stack = (function(){ const items = new weakMap(); class Stack{ constructor(){ items.set(this, []); } //其他方法 return Stack;})（）; 用栈解决的问题从十进制到二进制在现实生活中，我们主要使用十进制，但是在科学计算中，二进制是十分重要的，因为计算机中的所有的内容都是用二进制来表现的（0和1），没有十进制和二进制的相互转换能力，与计算机的交流就会十分的困难。要把十进制转换成二进制，我们可以将改十进制数字和2整除（二进制就是满二进一），知道结果为0为止，现在我们举个栗子，把十进制数字10转换成二进制的数组，大概的过程就是这样的： 大学的计算机课程一般都会先教这个进制转换。下面对应的算法描述： 123456789101112function divideby2(decNumber){ let remStack = new Stack(),rem,binaryString = &apos;&apos;; while (decNumber &gt; 0){ rem = Math.floor(decNumber % 2); remStack.push(rem); decNumber = Math.floor(decNumber / 2); } while(!remStack.isEmpty()){ binaryString += remStack.pop().toString(); } return binaryString ;} 从上面的算法中，我们很容易进行修改，让十进制可以转换成任意进制，除了让十进制和2整除转换为二进制，还可以传入其他任意进制的基数为参数，就像下面的算法是这样的： 123456789101112131415function baseConverter(decNumber , base){ let remStack = new Stack(), rem, binaryString = &apos;&apos;; digits = &apos;0123456789ABCDEF&apos;; while (decNumber &gt; 0){ rem = Math.floor(decNumber % base); remStack.push(rem); decNumber = Math.floor(decNumber / base); } while(!remStack.isEmpty()){ binaryString += remStack.pop().toString(); } return binaryString ;}","link":"/2020/11/01/JavaScript的栈/"},{"title":"JavaScript的类型详解","text":"JavaScript 的类型javaScript 语言定义了七种语言类型，我们看一下都有哪些？ Undefined null Boolean String Number Symbol (ES6 新添加) Object undefined 和 nullundefined：表示类型未定义null：表示定义了，但是值为空 Boolean表示逻辑上的真和假，这个类型只有两个值：true 和 false StringString 表示文本数据，String 的最大是 2^53 - 1，String 的意义并非“字符串”，而是字符串的 UTF16 编码 Number其中有一个特殊的值NaN，这个值是一个非自反的值： 12NaN === NaN // flaseNaN == NaN // flase NaN:占用了 9007199254740990，这原本是符合 IEEE 规则的数字； Infinity:无穷大 -Infinity:无穷小 1console.log(0.1+0.2 == 0.3); // false 这两边是不相等的，因为根据浮点数的特性来决定,这个是因为浮点数计算的精度问题。解决的方法：正确的比较方法是使用 JavaScript 提供的最小精度值 1console.log(Math.abs(0.1+0.2-0.3) &lt;= Number.EPSILON); SymbolSymbol 是 ES6 中引入的新类型，他是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象系统被用 Symbol 重塑创建 Symbol 的方式是使用全局 Symbol 函数： 1var mySymbol =Symbol(\"my school\") ObjectObject 表示对象的意思，是一切的有形和无形的物体的总称。在 JavaScript 中，对对象的定义是属性的集合,属性分为：数据属性和访问器属性。对于 JavaScript 来说，有几个基本类型都有一个对应的对象类型： Number String Boolean Symbol 也就是说 Number(3)和 3 并不是一个意思，一个是对象类型一个是 Number 类型。其中 Number、String、Boolean 这三个构造器是两用的，在和 new 搭配的时候，会产生对象，当直接调用的时候，可以进行强制类型转换。Symbol 函数就会比较特殊，直接使用 new 的话，会抛出错误，但是它仍然是 Symbol 对象的构造器。 其中数组时一种特殊的对象： 12345678var a = [];a[0] = 1;a['kim'] = 'jin';console.log(a.length) // 1console.log(a['kim']) // jinconsole.log(a.kim) // jinconsole.log(a) // [1, kim: \"jin\"] 我们注意一下数组通过数字进行索引，但是他们在实际的意义上也是对象，所以也可以包含字符串键值和属性（但是这些并不在长度的计算范围内） 值和引用在 JavaScript 中，对值的和引用赋值或是传递在语法上是没有区别的，主要是靠类型来进行决定的 1234567891011var a = 2;var b = a ; // b是a的值的一个副本b++;a;// 2b; // 3var c = [1,2,3];var d = c; // d 是[1,2,3.]的一个引用d.push(4);c; // [1,2,3,4]d; // [1,2,3,4] 也就是简单值(基本的类型值),总是通过复制的方式来进行赋值/传递的。包括 null、undefined、字符串、数字、布尔、ES6 中的 symbol。 复合值– 对象和函数，通过引用复制的方式来赋值/传递 12345678var a = [1,2,3];var b = a;a; // [1,2,3]b; // [1,2,3]b = [4,5,6];a; // [1,2,3]b; // [4,5,6] 我们通过下面的代码演示一下： 1234567891011 function foo(x){ x.push(4); x; // [1,2,3,4] x= [4,5,6]; x.push(7); x; // [4,5,6,7] }var a = [1,2,3];a; // [1,2,3,4] 上面的代码是向函数传递 a 的时候，实际就是将引用 a 的提个副本赋值给 x，而 a 的指向还是指向[1,2,3], x= [4,5,6]这一行代码并不会一想 a 的指向，所以 a 依旧指向[1,2,3,4]。 如果我们如果想要上面的代码打出的[4,5,6,7]的话，我们可以将代码修改为如下的方式： 1234567891011function foo (x){ x.push = 4; x; // [1,2,3,4] x.length = 0; // 清空数组 x.push(4,5,6,7); x; // [4,5,6,7]}var a = [1,2,3];a; // [4,5,6,7] 类型转换基本的类型转换如下表： 12345678910111213141516171819202122Boolean(Null) === FalseBoolean(Undefined) === FalseBoolean(0) === false // 数字除了0和NaN都为trueBoolean(NaN) === falseBoolean('') === false // 字符串除了‘’都为trueBoolean(Symbol(11))=== trueBoolean(Object()) === trueNumber(Null) === 0Number(undefined) === NaNNumber(Boolean(true)) === 1Number(Boolean(false)) === 0Number(Symbol('11')) // TypeErrorString(null) === 'null';String(undefined) === 'undefined';String(Boolean(true)) === TRUE;String(Boolean(false)) === FALSE;String(Symbol('11')) // TypeErrorObject(Null) // TypeErrorObject(undefined) // TypeError 上面的都是一些基本的，下面还有一些比较特殊的，我们进行详细的阐述 stringToNumber字符串到数字的类型转换，存储在一个语法结构，类型转换支持十进制、二进制和十六进制，如： 30 0b111 0o13 0XFF 但是 ParseInt 和 ParseFloat 使用的并不是这个转换，在不传入第二个参数的情况下 ParseInt 只支持 16 进制的前缀”0x”而且会忽略非数值的字符串，也不支持科学计数法，大部分的情况下 Number 是比 ParseInt 和 ParseFloat 更好的选择。 123console.log(parseInt('hhhj8889')); // NaNconsole.log(parseInt('8889hhhj')); // 8889console.log(parseInt('8hhhj889')); // 8 NumberToString在比较小的范围内，数字到字符串的转换完全就是直接的转换，但是当 Number 绝对值比较大或者是较小的情况下字符串的标识就会直接使用科学计数法表示。 装箱转换什么是装箱转换：就是将基本的数据类型转换成对象的对象，它是类型转换中一种相当重要的种类,但是转向机制会产生临时对象，在一些对性能比较高的场景下，我们应该尽量避免基本类型的装箱转换。 call本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。 拆箱转换拆箱转换：对象类型到基本类型的转换（拆箱转换）对象到String和Number的转换都遵循”先拆箱在转换”的规则，通过拆箱转换，吧对象编程基本类型，再从基本类型转换成对象的String或是Number。对于拆箱会尝试调用valueOf和toString来获取拆箱后的基本类型，如果valueOf和toString都不存在，或是没有返回基本类型，就会出现TYpeError的错误。 123456789101112131415var o = { valueof:()=&gt;{ console.log(\"valueOf\"); return (); } toString:()=&gt;{ console.log(\"toString\"); return(); }}o*2// valueOf// toString// TypeError 我们定义了一个对象o，o有valueOf和toString两个方法，这两个方法都返回一个对象，然后我们进行o2这个运算的时候，你会看见先执行了valueOf，接下来是toString，最后抛出了一个TypeError，这就说明了这个拆箱转换失败了。但是到了String的拆箱转换会有限调用toString。我们把刚刚的运算从o2换成String，我们发现调用的顺序发生了改变： 123456789101112131415var o = { valueof:()=&gt;{ console.log(\"valueOf\"); return (); } toString:()=&gt;{ console.log(\"toString\"); return(); }}String(o)// toString// valueOf// TypeErro","link":"/2020/11/01/JavaScript的类型详解/"},{"title":"Linux系统安装node.js的步骤","text":"下载自己需要的文件系统配置： 英文网址：https://nodejs.org/en/download/ 中文网址：http://nodejs.cn/download/ 我们可以通过uname -a的方式 来查看我们的Linux系统的位数是64位（ps：x86_64表示是64位的系统 i686 1386代表是32位的系统） 下载下来的tar文件上传到服务器并且解压，然后通关简历软连接编程全局1） 上传服务器可以是自己的任意路径，目前我存放的路径是root/2) 解压上传的文件（解压后的文件我将文件的名字改为node.js，这个地方可以自己随意，只要建立软连接的时候书写正确就可以）tar -xvf node-v10.15.3-linux-x64.tar.xzmv node-v6.10.0-linux-x64 nodejs确认一下nodejs下bin目录是否有node 和npm文件，如果有执行软连接，如果没有重新下载执行上边步骤3）建立软连接，变为全局 ① ln -s /root/nodejs/bin/npm /usr/local/bin/ ② ln -s /root/nodejs/bin/node /usr/local/bin/4)使用node-v显示当前的node的版本5）安装yarnnpm install -g yarn","link":"/2020/11/01/Linux系统安装node-js的步骤/"},{"title":"Promise","text":"简介Promise是一种异步编程的解决方案，比传统的解决方案– 回调行数和事件更加的合理和强大，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。而Promise出现主要是因为现阶段异步请求和数据之间存在依赖关系，如果使用传统的方法会产生很多难看的多层回调，这样的代码不利于进行阅读和后期的维护，俗称“回调地狱”，而且我们将错误处理代码和业务代码耦合在一起，造成代码的可读性变差，这个时候我们就引入Promise来降低异步编程的复杂性。 那么究竟什么是Promise呢？简单来说Promise就是一个容器，里面保存了某一个未来才会结束的事件（通常是一个异步操作）的结果，在语法的意义上面，Promise是一个对象，从他可以获取异步操作的消息。 Promise的特点： 对象的状态是不受外界的影响的，Promise 对象代表一个异步的操作。有三个状态：pending，fulfilled和reject。只有异步操作的结果，可以决定当前是哪一种状态。这也是Promise名字的由来，Promise是承诺的意思，意味着其他的手段是无法改变的。 一旦状态发生改变就不会在进行改变了。任何时候都是这个结果，Promise对象的状态改变，只有两种情况pending变成fulfilled或是pending变成reject，只要状态发生改变了，状态发生改变了，状态就会凝固，不会在发生改变。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 Promise 基本语法 Promise实例必须实现 then 这个方法 then()必须可以接收两个函数作为参数（第二个参数是可选的） Promise 基础用法Promise的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。形如这种形式： 1f1().then(f2); 我们可以看到上面的写法，将回调函数变成了链式的写法，城西的流程可以很清晰的看出来，而且有一套配套的方法，这样的话可以实现很多强大的功能。我们看一下Promise的实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调行数 12345promise.then(function(value) { // success}, function(error) { // failure}); 再举一个制定多个回调函数的例子，其形式为： 1f1().then(f2).then(f3); 下面我们就从一个例子进行入手，看一下上面的实现究竟是怎么样的： 12345678910111213141516171819202122232425262728293031323334353637383940414243runAsync1 = () =&gt;{ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log(&apos;异步任务1执行完成&apos;); resolve(&apos;随便什么数据1&apos;); }, 1000); }); return p;}runAsync2 = () =&gt;{ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log(&apos;异步任务2执行完成&apos;); resolve(&apos;随便什么数据2&apos;); }, 2000); }); return p;}runAsync3 = () =&gt;{ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log(&apos;异步任务3执行完成&apos;); resolve(&apos;随便什么数据3&apos;); }, 2000); }); return p;}runAsync1().then(function(data){ console.log(data); return runAsync2();}).then(function(data){ console.log(data); return runAsync3();}).then(function(data){ console.log(data);}); 上面的例子我们得到的结果是 结果的输出：每隔两秒输出每个异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到，那么如果我们返回的不是Promise对象呢，而是返回数据呢，我们将代码进行修改： 123456789101112runAsync1().then(function(data){ console.log(data); return runAsync2();}).then(function(data){ console.log(data); return &apos;直接返回数据&apos;; //这里直接返回数据}).then(function(data){ console.log(data);}); 打出的结果就是： 当我们要处理有reject的时候，我们使用的模板是： 1f1().then(f2(),f3()); 上面的代码是在f1()的状态由pending变成fulfilled的时候执行f2()函数，在pending编程rejected的时候执行f3()函数。我们之前一直使用 promise 来处理 ajax 的请求，我们通过代码看一下： 123456789101112const promise = new Promise((resolve, reject) =&gt; { $.ajax(&apos;https://github.com/users&apos;, (value) =&gt; { resolve(value); }).fail((err) =&gt; { reject(err); });});promise.then((value) =&gt; { console.log(value);},(err) =&gt; { console.log(err);}); 在上面的例子中，会在ajax请求成功后调用resolve回调函数来处理结果，如果请求失败就调用reject糊掉行数来处理错误，Promise 对象一般包含三个状态，分别是pending,fulfilled和rejected，对应ajax中的pending,success,error。成功获得值后状态就变为 fulfilled，然后将成功获取到的值存储起来，后续可以通过调用 then 方法传入的回调函数来进一步处理。而如果失败了的话，状态变为rejected,错误可以选择抛出（throw)或者调用reject方法来处理。then 方法可以被同一个 promise 调用多次，then方法必须返回一个promise 对象。` promise 的其他用法promise.catch()promise.catch() &lt;==&gt;.then(null, rejection)或.then(undefined, rejection)这个方法用来指定错误发生时的回调函数，其实它和then的第二个参数一样，用来指定reject的回调 123456789getNumber().then((data)=&gt;{ console.log(&apos;resolved&apos;); console.log(data); // 如果这里出错了，也会进入到catch函数中}).catch((reason)=&gt;{ console.log(&apos;rejected&apos;); console.log(reason);}); 效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中 promise.all()其实all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，也就是最慢的一个执行完成，才会执行回调函数。Promise.all方法用于将多个Promise实例，包装成一个新的Promise 实例。这个封装的方法提供了并行执行异步操作的能力，并且所有的异步操作都执行完成后才执行回调行数。我们还是使用上面的runAsync1，runAsync2，runAsync3的方法测试一下： 12345Promise.all([runAsync1(), runAsync2(), runAsync3()]).then(function(results){ console.log(results);}); 用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是： Promise.all接受一个promise对象的数组，待全部完成之后，统一执行success; promise.race()「谁跑的快，以谁为准执行回调」，这就是race方法，也就是我们如果使用了race的方法，一旦有执行完成的，就会执行回调行数，那我们继续举一个例子来看一下，现在我们将runAsync1方法的延时修改成1s来看一下： 12345Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results){ console.log(results);}); 这个时候我们打出的结果是： then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过 1 秒后，输出了他们结束的标志。romise.race接受一个包含多个promise对象的数组，只要有一个完成，就执行success。 promise.finally()finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。也就是finally的方法是与状态无关的 1234promise.then(result =&gt; {···}).catch(error =&gt; {···}).finally(() =&gt; {···}); // 这个函数是一定会被执行的 finally的实现原理是： 1234567Promise.prototype.finally = function (callback) { let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason }) );}; 也就是返回了原来的值： 1234567891011// resolve 的值是 undefinedPromise.resolve(2).then(() =&gt; {}, () =&gt; {})// resolve 的值是 2Promise.resolve(2).finally(() =&gt; {})// reject 的值是 undefinedPromise.reject(3).then(() =&gt; {}, () =&gt; {})// reject 的值是 3Promise.reject(3).finally(() =&gt; {}) Promise 的 resolve 和 reject 和 catch（当状态码为 404,5XX 的时候会进入到 reject 中进行执行） 123456789101112131415161718192021222324252627282930313233343536373839404142function load(){ var xmlhttp; if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera,Safari xmlhttp= new XMLHttpRequest(); }else{// code for IE6, IE5 xmlhttp= new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } xmlhttp.onreadystatechange= function(){ if (xmlhttp.readyState ==4 &amp;&amp; xmlhttp.status == 200) {//获得了请求数据 var expertinfolist = xmlhttp.responseText; //发送请求数据到myDiv document.getElementById(&quot;myDiv&quot;).innerHTML=expertinfolist; } } var url=&quot;expert_ZFTservlet?expert_name=&quot;+&quot;曾攀&quot;; xmlhttp.open(&quot;GET&quot;, &apos;/js/jquery-ui.min.js&apos;, true); xmlhttp.send();} a =()=&gt;{console.log(111)}b =() =&gt;{console.log(222)}promise = new Promise((a,b)=&gt;{ load()}); 12345678910111213141516171819202122232425262728293031323334353637383940function load(){ var xmlhttp; if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera,Safari xmlhttp= newXMLHttpRequest(); }else{// code for IE6, IE5 xmlhttp= newActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } xmlhttp.onreadystatechange= function(){ if (xmlhttp.readyState ==4 &amp;&amp; xmlhttp.status == 200) {//获得了请求数据 var expertinfolist = xmlhttp.responseText; //发送请求数据到myDiv document.getElementById(&quot;myDiv&quot;).innerHTML=expertinfolist; } } var url=&quot;expert_ZFTservlet?expert_name=&quot;+&quot;11&quot;; xmlhttp.open(&quot;GET&quot;, &apos;&apos;, true); xmlhttp.send();}const promise = new Promise((a,b)=&gt;{ load()}).then(()=&gt;{ console.log(111)}).catch(()=&gt;{console.log(222)})","link":"/2020/11/01/Promise/"},{"title":"React生命周期的图解","text":"生命周期的概括图在hook出现之前，生命周期是很重要的概念，我们今天看一下生命周期一般都是在上面阶段来进行调用： 生命周期的划分初始化阶段 defaultProps 设置组件的默认属性 constructor 设置组件的初始化状态 componentWillMount（）即将被废弃的声明周期 render()组件渲染 componentDidMount() 组件已经被渲染到页面中后触发 componentWillMount被废弃的理由：如果在componentWillMount中发送异步请求，在SSR（服务端渲染）的情况下，服务端与客户端共用一套组件原代码，此时会发出两次请求（服务端请求一次、客户端请求一次），服务端的请求是多余的。如果将异步请求放在componentDidMount中，服务器不会执行componentDidMount生命周期函数，可以减少不必要的请求。componentDidMount:另外提醒在這邊綁定DOM eventListener，記得在willUnMount取消綁定EventListener，如果重新render元件會再次執行DidMount，造成過多的綁定事件。 运行阶段 componentWillReceiveProps(nextProps)组件接收到属性时触发,丢弃 shouldComponentUpdate(nextProps, nextState) componentWillUpdate(nextProps, nextState)组件即将被更新时触发，丢弃 componentDidUpdate(nextProps, nextState) 组件被更新完成后触发。页面中产生了新的DOM的元素，可以进行DOM操作 componentWillReceiveProps(nextProps):会回传更新过的props,并且可以使用setState来更新state，但是这里使用setState，并不会重新执行componentWillReceiveProps，因为ReceiveProps只会在更新传递的props的时候进行调用。 shouldComponentUpdate:当组件接收到新属性，或者组件的状态发生改变时触发。组件首次渲染时并不会触发,这个生命周期的返回值是布尔值，会显示后续是否进行重新的渲染 componentWillUpdate：在这个生命周期使用setState，会导致重新跑回到updata的生命周期，然后在跑到componentWillUpdate，如果不慎用的话，会导致反复的执行。 12345shouldComponentUpdate(newProps, newState) { if (newProps.number &lt; 5) return true; return false}//该钩子函数可以接收到两个参数，新的属性和状态，返回`true/false`来控制组件是否需要更新。 我们使用这个生命周期一般用于优化，有的时候，我们在界面上只需要更新一个很小的组件，而一个父组件的更新会造成整个子组件都进行渲染，形成一个崭新的虚拟DOM，但是这样的话，会造成资源的浪费，我们可以根据实际的开发情况在shouldComponentUpdate()生命周期加入条件，来进行性能的优化。 销毁阶段 componentWillUnmount()有的是对轮询的请求的清理，有的是对定时器的清理，根据实际情况来订。 将要废弃的声明周期 componentWillMount() -&gt; 17版废弃 componentWillReceiveProps(nextProps) -&gt; 17版废弃 componentWillUpdate（nextProps, nextState) -&gt; 17版废弃","link":"/2020/11/01/React生命周期的图解/"},{"title":"React组件中的constructor概述","text":"在react官网中，我们看到经常会有这样声明组件的，但是我们自己在写的时候很少会使用constructor，super，那么这两个方法到底是用来做什么的呢？在写react中一定要写吗？我们在下面具体看一下： 123456789101112131415class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); }} 上面的代码是在官网粘贴下来的，但是在操作的时候，我们发现们不写constructor，super也是没有问题的，并不会影响我们的执行。为什么我们要是有构造函数，后来翻阅了一下原型链的内容在es5中，是没有类的概念的，所以都要在原型链上实现，我们看一下下面的代码： 123constructor(props) { super(props);} 相当于对类进行一个new的操作，我们真正在引用的时候，使用的是这个类的实例。而我们现在在写的时候，不写上面的部分，并不是我们在运行中不再运行了，而是不管我们写不写constructor，在new实例的时候，都会为我们补上constructor。 那ES5和ES6在constructor上面扮演的角色是否是相同的呢？ ES5的继承，实质上是先创造子类的实例对象this,然后再将父类的方法添加到this上面去(Parent.apply(this)) ES6的继承机制：先创造父类的实例对象this,(必须先调用super方法)，然后再用子类的构造函数修改this。 既然讲到了这里，我们很好奇，在之前我们写的时候是需要对相对应的函数进行绑定的，那我们什么时候需要绑定，什么时候是不需要绑定的呢？ 123456789101112131415class Clock extends React.Component { state = {date: new Date()}; onChange= () =&gt;{ this.setState({data:111}) } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;Button onClick = {this.onChange()}&gt;确认&lt;/Button&gt; &lt;/div&gt; ); }} 上面的函数是没有问题的，可以正常的运行，我们需要分析一下上面的函数中的this的指向的问题，对于箭头函数来说，this的指向看的上下文，现在我们可以看到这个上下文是clock的这个实例，上面一定有这个方法，所以不会报错。那我们看一下下面的这个写法： 123456789101112131415class Clock extends React.Component { state = {date: new Date()}; onChange (){ this.setState({data:111}) } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;Button onClick = {this.onChange()}&gt;确认&lt;/Button&gt; &lt;/div&gt; ); }} 上面的函数是function的方式来写这个函数，我们知道对于这样的方法，我们是谁调用这个方法this就会指向谁，我们通过console.log（）打出发现this指向的是undefined，其实是&lt;Button onClick = {this.onChange()}&gt;确认&lt;/Button&gt;这个dom，但是由于在react中，dom节点为虚拟dom，所以最后打出的是undefined，所以我们这样使用是有问题的。 super中的props是否必要？ 作用是什么？？ 可以不写constructor，一旦写了constructor，就必须在此函数中写super(), 此时组件才有自己的this，在组件的全局中都可以使用this关键字， 否则如果只是constructor 而不执行super()那么以后的this都是错的！！！ super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。只有一个理由需要传递props作为super()的参数，那就是你需要在构造函数内使用this.props","link":"/2020/11/01/React组件中的constructor概述/"},{"title":"Async/Await简介与用法","text":"关于TypeScriptTypeScript是JavaScript的超集，主要提供类型系统和对ES6的支持，由Microsoft开发，第一个版本发布于2012。 TypeScript的优势 TypeScript增加了代码的可读性和可维护性 大部分的函数函数看看类型的定义就已经知道该如何使用了 可以在编译的阶段就发现了大量的错误，防止在运行中发现过多的错误 增强了编辑器和IDE的功能。 TypeScript非常的包容 TypeScript是JavaScript的超集，.js文件可以直接将名字转换为.ts即可 即使不显式的定义类型，也可以自动的做出类型的推论 可以定义从简单到复杂的一切类型 即使TypeScript编译报错，也可以生成JavaScript文件 TypeScript的劣势 需要一定的学习成本，需要理解接口(Interfaces)、泛型(Generics)、类(Classes)、枚举类型(Enums)等前端工程师不是很熟悉的东西，而且现阶段的中文资料也不是很多 短期内可能增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期进行维护的额项目。TypeScript能够减少维护的成本 集成到构建流程需要一定的工作量 可能和一些库结合的并不是很完美原始数据类型对于前端开发来说，主要的类型可以 分成两部分：原始数据类型和对象类型。原始数据类型包括：布尔值，数值，字符串，null，undefined以及ES6中的新类型symbol。现在我们主要看一下这些原始值在TypeScript中的应用。布尔值布尔值是最基本的数据类型，在TypeScript中，使用Boolean定义布尔值类型：1234let isTrue:boolean = false;// 可以通过编译// 对于后面来说，没有特殊强调错误代码片段，就默认为编译通过了。 注意一下，使用构造函数Boolean创建的对象不是布尔值： 123let createdByNewBoolean : boolean = new Boolean(1);// index.ts(1,5): error TS2322: Type 'Boolean' is not assignable to type 'boolean'. 上面代码报错的原因是new Boolean()返回一个Boolean对象： 1let createdByNewBoolean : Boolean= new Boolean(1); 直接调用Boolean也可以返回一个 boolean 类型： 1let createdByBoolean: boolean = Boolean(1); 在TypeScript中，boolean 是 JavaScript中的基本类型，而Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null和 undefined）一样，不再赘述。 数值使用nubmber定义数值类型： 123456let decLiteral:number=6;let hexLiteral:number = 0xf00d;let binaryLiteral:number = 0b1010; // ES6中的二进制表示法let octalLiteral:number =0o744;// ES6中的八进制表示法let notNumber:number =NaN;let infinityNumber:number = Infinity; 上面的编译的结果是什么： 123456var decLiteral = 6;var hexLiteral = 0xf00d;var binaryLiteral = 10;var octalLiteral= 484;var notNumber = NaN;var infinityNumber = Infinity; 其中0b1010 和 0o744 是ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。 字符串使用string定义字符串类型： 1234567// 普通字符串let myName:string = &apos;kim&apos;;let myAge:number = 25;// 模板字符串let sentence:string = `Hello,my name is ${myName}.I&apos;ll be ${myAge + 1} years old next month`; 编译结果： 12345var myName = &apos;kim&apos;;var myAge = 25;// 模板字符串let sentence = &quot;Hello,my name is&quot;+myName+&quot;.\\nI&apos;will be&quot;+(myAge+1)+&quot;years old next month&quot;; 空值JavaScript没有空值(void)的概念，在TypeScript中，可以用void表示没有任何返回值的函数。 123function akertName():void{ alert(&apos;My name is kim&apos;);} 声明一个void类型变量是没有什么用，因为我们只能将它赋值为undefined和null: 1let unusable:void = undefined Null和undefined在TypeScript中，可以使用null和undefined来定义这两个原始数据类型： 12let u:undefined = undefined;let n:null = null; undefined只能赋值为undefined，null只能赋值为null。但是这二者和void还是有区别的，null和undefined是所有类型的子类型，也就是说undefined类型的变量，可以赋值给number类型的变量： 1234//这样写也是没有问题的let num:number =undefined;let u: undefined;let num: number = u; 但是void的类型并不是这样的，不能讲void类型的变量不能赋值给number类型的变量： 1234let u: void;let num: number = u;//index.ts(2,5): error TS2322: Type 'void' is not assignable to type 'number'. 任意值任意值（Any）用来表示允许赋值为任意类型。 什么是任意值类型如果是一个普通类型，在赋值过程中改变类型是不被允许的: 1234let myFavoriteNumber:string ='seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 但如果是 any 类型，则允许被赋值为任意类型。 12let myFavoriteNumber : any ='seven';myFavoriteNumber = 7; 任意值的属性和方法在任何值上访问任何属性都是允许的： 123let anyThing :any = 'hello';console.log(anyThing.myName);console.log(anyThing.myName.firstName); 也允许调用任何方法： 1234let anyThing : any = 'kim';anyThing.setName('Tom');anyThing.setName('Tom').sayHello();anyThing.myName.setFirstName('kim'); 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。 未声明类型的变量变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型： 1234let something;something = 'seven';something = 7;something.setName('kim'); 上面的代码等价于： 1234let something:any;something = 'seven';something = 7;something.setName('kim'); 类型推论如果没有明确的字段，那么TypeScript会依照类型推论的规则判断出一个类型。下面的代码虽然没有指定类型，但是会在编译的时候报错： 1234let myFavoriteNumber = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 上面的代码等价于： 1234let myFavoriteNumber:string = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 但是为什么这和any类型的还是有区别的，二者的区别在于在声明的时候没有赋值的话，就会判断成any类型，在后续就不会再进行检查。 联合类型联合类型表示取值可以为多种类型中的一种。让我们先举个小栗子： 123let myFavoriteNumber:string | number;myFavoriteNumber = 'seven';myFavoriteNumber = 7; 上面的例子说明myFavoriteNumber可以是string类型或是number类型的。但是如果我们给这个值给一个布尔值，就会报错。 12345let myFavoriteNumber:string | number;myFavoriteNumber = true;// index.ts(2,1): error TS2322: Type 'boolean' is not assignable to type 'string | number'.// Type 'boolean' is not assignable to type 'number'. 联合类型使用 | 分隔每个类型。这里的string|number的意思是，允许myFavoriteNumber的类型是string或是number，但是不能是其他类型。 访问联合类型的属性或方法当TypeScript不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性和方法： 12345function getLength(something: string | number): number { return something.length;}// index.ts(2,20): error TS2339: Property 'length' does not exist on type 'string | number'.// Property 'length' does not exist on type 'number'. 上例中，length 不是string 和 number 的共有属性，所以会报错。访问 string 和 number 的共有属性是没问题的： 123function getString(something:string | number):string{ return something.toString();} 联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型： 1234567let myFavoriteNumber:string|number;myFavoriteNumber = 'seven';console.log(myFavoriteNumber.length); // 5myFavoriteNumber = 7;console.log(myFavoriteNumber.length); // 编译时报错 // index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'. 上例中，第二行的 myFavoriteNumber被推断成了 string，访问它的length属性不会报错。而第四行的myFavoriteNumber 被推断成了 number，访问它的 length属性时就报错了。 对象的类型 – 接口在TypeScript中，我们使用接口来定义对象的类型。 什么是接口在面向对象的语言中，接口是一个很重要的概念，他是对行为的抽象，而具体如何行动需要类去实现。TypeScript中的接口就是一个很灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对【对象的形状】进行描述。简单的例子： 12345678interface Person{ name:string; age:number;}let kim:Person={ name:'kim', age:18} 在上面的例子中我们定义了一个接口Person，接着定义可一个变量kim，它的类型是person，这样，我们就约束了kim的形状和接口Person一致。接口一般首字母大写。接口的变量比接口少一些或是多一些属性是不允许的： 1234567891011121314151617181920212223242526interface Person { name: string; age: number;} let kim: Person = { name: 'kim',}; // index.ts(6,5): error TS2322: Type '{ name: string; }' is not assignable to type 'Person'.// Property 'age' is missing in type '{ name: string; }'.interface Person { name: string; age: number;} let kim: Person = { name: 'kim, age: 25, website: 'http://kim.com',}; // index.ts(9,3): error TS2322: Type '{ name: string; age: number; website: string; }' is not assignable to type 'Person'.// Object literal may only specify known properties, and 'website' does not exist in type 'Person'. 可选属性有的时候我们希望不要完全匹配成一个形状，那么我们可用一些可选属性： 12345678910111213interface Person { name: string; age?: number;} let kim: Person = { name: 'kim',};let kimi: Person = { name: 'kimi', age:28}; 可选属性的意思就是这个属性的值可以是不存在的，但是在这种情况下依旧不允许添加未定义的属性，我们在下面举个栗子： 12345678let Tom: Person = { name: 'Tom', age:28, website:'http://www.baidu.com',};// examples/playground/index.ts(9,3): error TS2322:// Type '{ name: string; age: number; website: string; }' is not assignable to type 'Person'.// Object literal may only specify known properties, and 'website' does not exist in type 'Person'. 任意属性有的时候我们希望几口允许任意的属性，可以使用如下的方式: 12345678910interface Person{ name:string; age?:number; [propName:string]:any;}let kim :Person ={ name:'kim', website:'http://www.baidu.com',}; 我们对于上面的代码进行解析，使用[propName:string]定义了任意属性取string类型的值。但是需要注意的是，一旦定义了任意属性，那么确定属性和可选属性都必须是它的子属性： 1234567891011121314151617181920interface Person{ name:string; age?:number; [propName:string]:string;}let kim :Person ={ name:'kim', age:25, website:'http://www.baidu.com',}// index.ts(3,3): error TS2411: //Property 'age' of type 'number' is not assignable to string index type 'string'.// index.ts(7,5): //error TS2322: Type '{ [x: string]: string | number; name: string; age: number; website: string; }' is not //assignable to type 'Person'.// Index signatures are incompatible.//Type 'string | number' is not assignable to type 'string'.//Type 'number' is not assignable to type 'string'. 上例中，任意属性的值允许是 string，但是可选属性 age 的值却是number，number 不是string的子属性，所以报错了。 另外，在报错信息中可以看出，此时 { name: ‘Xcat Liu’, age: 25, website: ‘http://xcatliu.com’ } 的类型被推断成了 { [x: string]: string | number; name: string; age: number; website: string; }，这是联合类型和接口的结合。 只读属性有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用readonly定义只读属性： 12345678910111213141516interface Person { readonly id: number; name: string; age?: number; [propName: string]: any;} let xcatliu: Person = { id: 89757, name: 'kim', website: 'http://www.baidu.com',}; xcatliu.id = 9527; // index.ts(14,9): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property. 上面的id属性是只读属性，id在初始化之后，又被赋值了，所以会报错。只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候。 1234567891011121314151617interface Person { readonly id: number; name: string; age?: number; [propName: string]: any;} let xcatliu: Person = { // 没有给id进行赋值 name: 'Xcat Liu', website: 'http://xcatliu.com',}; xcatliu.id = 89757; // 错误 // index.ts(8,5): error TS2322: Type '{ name: string; website: string; }' is not assignable to type 'Person'.// Property 'id' is missing in type '{ name: string; website: string; }'.// index.ts(13,9): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property. 数组的类型[类型+方括号]表示法最简单的方法是使用[类型+方括号]来标识数组： 1let arr:number[] =[1,2,3,4,5] 数组的项中不允许出现其他的类型： 12345let arr:number[] =[1,'2',3,4,5];//index.ts(1,5): error TS2322: Type '(number | string)[]' is not assignable to type 'number[]'.//Type 'number | string' is not assignable to type 'number'.//Type 'string' is not assignable to type 'number'. 现在的[1,'2',3,4,5]的类型被推断称为(number|string)[],这个是联合类型和数组的结合。 12345let arr2: number[] = [1,2,3,4,5,6,7];arr2.push('8')//index.ts(2,16): error TS2345: Argument of type 'string' is //not assignable to parameter of type 'number'. 数组泛型也可以使用数组泛型（Generic） Array&lt;elemType&gt; 来表示数组： 1let arr3: Array&lt;number&gt; = [1, 1, 2, 3, 5]; 用接口表示数组接口也可以用来描述数组： 1234interface NumberArray{ [index:number]:number;}let arr4 : NumberArray=[1,1,2,3,4]; NumberArray 表示：只要 index 的类型是 number，那么值的类型必须是 number。 any 在数组中的应用一个比较常见的做法是，用any表示数组中允许出现任意类型： 1let list : any[] =['kim',25,{website:'www.baidu.com'}]; 类数组类数组不是数组类型，比如arguments： 12345function sum(){ let args:number[] = arguments;}// index.ts(2,7): error TS2322: Type 'IArguments' is not assignable to type 'number[]'.// Property 'push' is missing in type 'IArguments'. 事实上常见的类数组都有自己的接口定义，如 Arguments,NodeList, HTMLCollection 等： 123function sum() { let args: IArguments = arguments;} 函数的类型函数的声明在JavaScript中，有两种常见的定义函数的方式–函数声明（Function Declaration）和函数表达式（Function Expression）： 12345678// 函数声明（Function Declaration）function sum (x,y){ return x+y;}//函数表达式（Function Expression）let mySum = function （x,y）{ return x + y;} 一个函数有输入和输出，要在TypeScript中对齐进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义比较简单： 123function sum (x:number,y:number):number{ return x+y;} 但是输出多余的(或少于要求)参数，是不被允许的： 12345678function sum (x:number,y:number):number{ return x+y;}sum (1,2,3);// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.sum (1);//index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target. 函数表达式如果我们现在想要写一个函数表达式的定义，我们可能会这样写： 123let muSum = function(x:number,y:number):number{ return x+y;} 这个是可以通过编译的，但是在事实上，上面的代码只对等号右侧的匿名行数进行了类的定义，而等号左侧的mySum，是通过赋值操作对类型进行推断出来的。如果需要我们手动给mySum添加类型，代码应该只这样写的： 123let mySum:(x number,y:number) =&gt;number = function (x:number,y:number):number{ return x+y;} 在TypeScript的类型定义中，=&gt;用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型，应用是十分广泛的。 接口中函数的定义我们也可以使用接口的当时来定义一个函数需要符合的形象： 12345678interface SearchFunc{ (source:string,subString:string):boolean}let mySearch : SearchFunc;mySearch = function (source:string,subString:string){ return source.search(subString) !== -1;} 可选参数前面，输入多余的(或是少于要求的)的参数，是不被允许的，那么怎么定义可选的参数呢？与接口中的可选属性相似，也是使用？表示可选参数： 123456789function buildName(firstName: string, lastName?: string) { if (lastName) { return firstName + ' ' + lastName; } else { return firstName; }}let kimXue= buildName('Xcat', 'Xue');let kim= buildName('kim'); 需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必须参数了： 1234567891011function buildName(firstName?: string, lastName: string) { if (firstName) { return firstName + ' ' + lastName; } else { return lastName; }}let kimXue= buildName('Xcat', 'Xue');let kim= buildName('kim'); // index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter. 上面的代码会报错，因为在first那么这个属性的后面还有必须的属性，因此报错。 参数默认值在ES6中，我们允许给函数的参数添加默认值，TypeScript会将添加了默认值的参数识别为可选参数： 12345function buildName(firstName: string, lastName: string = &apos;Xue&apos;) { return firstName + &apos; &apos; + lastName;}let kimXue= buildName(&apos;Xcat&apos;, &apos;Xue&apos;);let kim= buildName(&apos;kim&apos;); 此时就不受「可选参数必须接在必需参数后面」的限制了： 12345function buildName(firstName: string = &apos;kim&apos;, lastName: string) { return firstName + &apos; &apos; + lastName;}let kimXue= buildName(&apos;Xcat&apos;, &apos;Xue&apos;);let kim= buildName(&apos;kim&apos;); 剩余参数ES6中，可以使用...rest的方式获取函数中的剩余参数(rest参数)： 12345678function push(array,...items){ items.forEach(function (item){ array.push(item); })}let a = [];push(a,1,2,3); 事实上，items是一个数组，所以我们可以用数组的类型去定义它： 12345678function push(array:any[],...items:any[]){ items.forEach(function (item){ array.push(item); })}let a = [];push(a,1,2,3); 和上面的代码一样，rest参数只能是最后一个参数。 重载重载允许一个函数接受不同数量或是类型的参数，并作出不同的处理。比如，我们需要实现一个函数reverse，输入数字123的时候，输出的就是数字321，输入字符串‘hello’的时候，输出翻转的字符串‘olleh’，利用联合类型，我们可以这么实现： 1234567function reverse(x: number | string): number | string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); }} 然而这样写的话，还是有一个缺点，就是不能够精确地表达，输入为数字的时候，输出的也应该是数字，输入为字符串的时候，输出也应该为字符串。这时，我们可以用重载来实现多个这样的函数： 123456789function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); }} 类型断言类型断言可以用来绕过编译器的类型判断，手动指定一个值的类型。 语法1234&lt;类型&gt;值// 或值 as 类型// 在TSX语法 (React的JSX语法的TS版）中必须用后一种 例子：将一个联合类型的变量指定为一个更加具体的类型 当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法： 123456function getLength(something: string | number): number { return something.length;} //index.ts(2,20): error TS2339: Property 'length' does not exist on type 'string | number'.//Property 'length' does not exist on type 'number'. 这样的时候我们就需要使用类型断言，现将something断言成string： 1234567function getLength(something: string | number): number { if ((&lt;string&gt;something).length) { return (&lt;string&gt;something).length; } else { return something.toString().length; }} 类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的： 123456function toBoolean(something: string | number): boolean { return &lt;boolean&gt;something;} // index.ts(2,10): error TS2352: Type &apos;string | number&apos; cannot be converted to type &apos;boolean&apos;.// Type &apos;number&apos; is not comparable to type &apos;boolean&apos;. 声明文件当我们使用第三方库时，我们需要引用它的声明文件： 声明语法当我们使用第三方库，比如jQuery，我们通常这样获取一个id是foo元素： 123$(&apos;#foo&apos;);// orjQuery(&apos;#foo&apos;); 但是在 TypeScript 中，我们并不知道$ 或jQuery是什么东西。这时，我们需要使用 declare关键字来定义它的类型，帮助 TypeScript 判断我们传入的参数类型对不对。 12declear var jQuery:(string) =&gt;any;jQuery(&apos;#foo&apos;); declare 定义的类型只会用于编译时的检查，编译结果中会被删除。 声明文件通常我们会把类型声明放在一个单独的文件中，这就是声明文件： 123// jQuery.d.ts declare var jQuery: (string) =&gt; any; 我们约定声明文件以.d.ts为后缀。然后在使用到的文件的开头，用「三斜线指令」表示引用了声明文件： 12/// &lt;reference path=\"./jQuery.d.ts\" /&gt;jQuery('#foo');","link":"/2020/11/01/TypeScript的入门/"},{"title":"antDesign+react实现表格","text":"我们想要开发一个这样的表格，那么我们要怎么通过ant design和react来进行开发 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import React,{Fragment,PureComponent} from 'react';import moment from 'moment'; //引入了moment的库import {Table} from 'antd';const {column} = Table;class App extends PureComponent{//测试数据，但是key值一定要有，否则会有warning出现let testValue =[{ key:'1' startTime:'1546916859979', endTime:'1546916859990', backup:'20190111136858', backupNoSize:'52461', status:'SUCCESS'},{ key:'21' startTime:'1546916856979', endTime:'1546916856990', backup:'201901111375212', backupNoSize:'52481', status:'FAILD'}] state ={data:testValue } //我们想要在表格中显示的数据// 对于时间进行标准化的表示 formateDate = text =&gt;{ if(text !== '' &amp;&amp; text !==undefined &amp;&amp; text !== null &amp;&amp; text !== 'none'){ text = moment(pareseInt(text)).formate('YYYY/MM/DD hh:mm:ss'); return text; }else{ text ='--'; return text; } }// 对操作进行处理operateCell =(text,recorder) =&gt;{ switch (recorder.status){ case 'SUCCESS': return (&lt;div&gt;&lt;a&gt;恢复&lt;/a&gt;&lt;a&gt;删除&lt;/a&gt;&lt;/div&gt;) default： case:(&lt;a&gt;删除&lt;/a&gt;) }} render(){ return ( &lt;Table dataSource ={this.state.data}&gt; &lt;Column title ='序号' dataIndex='backupNo' render ={(text,recorder,index) =&gt; &lt;span&gt;{index +1}&lt;/span&gt;}/&gt; &lt;Column title ='开始时间' dataIndex='startTime' render ={text =&gt;this.formateDate(text)}/&gt; &lt;Column title ='开始时间' dataIndex='endTime' render ={text =&gt;this.formateDate(text)}/&gt; &lt;Column title ='备份集' dataIndex='backup'/ &gt; &lt;Column title ='备份大小' dataIndex='backupNoSize' /&gt; &lt;Column title ='状态' dataIndex='status' /&gt; &lt;Column title ='操作' dataIndex='operate' render ={(text,recorder) =&gt;this.operateCell(text，recorder)}/&gt; ) }}","link":"/2020/11/01/antDesign-react实现表格/"},{"title":"antDesign+react实现选择不同的下拉框出现不同的组件","text":"在选择不同的下拉框的时候出现不同的组件，具体的实现效果就是： 我具体的做法是，在第一个下拉框作为一个控制组件，后面的显示结果通过判断第一个下拉框选择的不同值进行显示的划分。首先先对第一个组件进行封装,，该文件的文件名的index.js： 1234567891011121314151617181920212223242526import React,{PureComponent} from 'react';import {Select} from 'antd';import SwitchInterval from '/SwitchInterval 'const Option = Select.Option ;class FirstSelect extends PureComponent { state = {value:''}; // 向子组件传值 handleChange = value =&gt;{ this.setState(()=&gt;({value})); } render(){ const {value} =this.state; return( &lt;div&gt; &lt;Select value ={value} onChange ={this.handleChange}&gt; &lt;Option value =''&gt;请选择&lt;/Option &gt; &lt;Option value ='day'&gt;每天运行&lt;/Option &gt; &lt;Option value ='week'&gt;每周运行&lt;/Option &gt; &lt;Option value ='month'&gt;每月运行&lt;/Option &gt; &lt;/Select}&gt; &lt;SwitchInterval /&gt; &lt;/div&gt;) }} 现在我们对子组件进行封装，子组件的文件名为SwitchInterval.js ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import React,{PureComponent} from 'react';import {Select} from 'antd';import SwitchInterval from '/SwitchInterval 'const Option = Select.Option ;// 对日期组件进行封装class DayShow extends PureComponent{ InitTime =() =&gt;{ let timeValues =[]; for(let i = 0; i&lt; 24; i++){ timeValues.push(i+':00'); } return timeValues; }; render(){ return( &lt;div&gt; &lt;span&gt;时间为&lt;/span&gt; &lt;Select defaultValue ='0:00'&gt; {this.InitTime().map(value =&gt;(&lt;Option key ={value} value ={value}&gt;{value}&lt;/Option&gt;))} &lt;/Select&gt; &lt;/div&gt; ); }}// 对星期组件进行封装class WeekShow extends PureComponent{ InitWeek =() =&gt;{ let weekValues =[ {value:1,label:'星期一'}, {value:2,label:'星期二'}, {value:3,label:'星期三'}, {value:4,label:'星期四'}, {value:5,label:'星期五'}, {value:6,label:'星期六'}, {value:7,label:'星期日'}, ]; return weekValues ; }; render(){ return( &lt;div&gt; &lt;span&gt;日期为&lt;/span&gt; &lt;Select defaultValue ='星期一'&gt; {this.InitWeek().map(({value,label}) =&gt;(&lt;Option key ={value} value ={value}&gt;{label}&lt;/Option&gt;))} &lt;/Select&gt; &lt;/div&gt; ); }}// 对月份组件进行封装class MonthShow extends PureComponent{ InitMonth =() =&gt;{ let monthValues =[]; for(let i = 1; i&lt; 32; i++){ timeValues.push(i); } return monthValues ; }; render(){ return( &lt;div&gt; &lt;span&gt;日期为&lt;/span&gt; &lt;Select defaultValue ='1'&gt; {this.InitMonth().map(value =&gt;(&lt;Option key ={value} value ={value}&gt;{value}&lt;/Option&gt;))} &lt;/Select&gt; &lt;/div&gt; ); }}class SwitchInterval extends PureComponent{ render(){ if(this.props.value ==='day' ){ return( &lt;div&gt; &lt;DayShow /&gt; &lt;/div&gt; ); }else if(this.props.value ==='week' ){ return( &lt;div&gt; &lt;WeekShow /&gt; &lt;DayShow /&gt; &lt;/div&gt; ); }else if(this.props.value ==='month'){ return( &lt;div&gt; &lt;DayShow /&gt; &lt;MonthShow /&gt; &lt;/div&gt; ); }else{ return null; } }}export default SwitchInterval ;","link":"/2020/11/01/antDesign-react实现选择不同的下拉框出现不同的组件/"},{"title":"antDesign+react获取输入框中的值","text":"具体的应用的场景是，在输入的时候对数据进行获取数据，在保存的时候，将获取的数据进行打印： 具体的代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041import React,{Fragment,PureComponent} from 'react';import moment from 'moment'; //引入了moment的库import {Input} from 'antd';class InputSave extends PureComponent{ state ={value1:'',value2:''}//在输入框发生变化的时候修改状态的值 handleMaxRestoreUp = ()=&gt;{ if(event &amp;&amp; event.target &amp;&amp; event.target.value){ let value = event.target.value; this.setState(()=&gt;({value1:value })) } }//在输入框发生变化的时候修改状态的值 handleMaxBackUp= ()=&gt;{ if(event &amp;&amp; event.target &amp;&amp; event.target.value){ let value = event.target.value; this.setState(()=&gt;({value1:value })) } }//点击保存的时候打出输入框中的值 saveData=()=&gt;{ console.log(this.state.value1); console.log(this.state.value2); } render(){ return( &lt;div&gt; &lt;span&gt;最大的备份速度&lt;/span&gt; &lt;Input defaultValue ='20' onChange ={event =&gt; this.handleMaxBackUp(event)}/&gt; &lt;span&gt;MB 最大恢复速度&lt;/span&gt; &lt;Input onChange ={event =&gt; this.handleMaxRestoreUp(event)} /&gt; &lt;span&gt;MB&lt;/span&gt; &lt;div&gt; &lt;Button type ='primary' onClick{()=&gt;{this.saveData()}}&gt;保存&lt;/Button &gt; &lt;/div&gt; &lt;/div&gt;) }}","link":"/2020/11/01/antDesign-react获取输入框中的值/"},{"title":"antDesign+react表单验证注意事项","text":"我们先用下面的代码实现一下我们要求的表单： 对于表单验证在antdesign里面有非常详细的描述，我主要描述的是对于相关的布局的问题，比如说我们想要实现下面的这个在点击‘测试连接’按钮的时候，进行表单的验证。先写一下逻辑代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TestConnect extends Component{ static propTypes ={ form:PropsType.object }; //点击保存的时候进行验证 handleSubmit = e =&gt;{ e.preventDefault(); this.props.form.validateFields((err,values) =&gt;{ if(!err){ console.log('receive the value of input ' + values); } }) } render(){ const {getFieldDecorator} = this.props.form; const formItemLayout ={ label:( &lt;span&gt; &lt;b&gt;备份路径&lt;/b&gt;备份集保存的远程路径，支持nfs协议 &lt;/span&gt; ), wrapperCol:{span:17} }; return( &lt;Row&gt; &lt;Col&gt; &lt;Form onSubmit ={this.handleSubmit} span ={24} layout ='vertical'&gt; &lt;FormItem {...formItemLayout }&gt; &lt;Row&gt; &lt;Col span={12}&gt; {getFieldDecorator('testPath',{ rules:[{required:true,message:'备份路径不能为空'}] })(&lt;Input placeholder='请输入远程路径'/&gt;)} &lt;/Col&gt; &lt;Col offset={1} span={4}&gt; &lt;Button htmlType ='submit' type = 'primary'&gt; 测试连接 &lt;/Button&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;/FormItem &gt; &lt;/Form&gt; &lt;Col&gt; &lt;/Row&gt; ); }}const Test = Form.create()(TestConnect); 对于布局来说，使用的是grid布局，对于antdesign库，提供了进行校验的接口，但是对于布局要使用FormItem来进行书写，这样的话，就可以避免在进行校验的时候，发生布局混乱的问题，不会出现在错误信息显示的时候，将下面的div挤下去。","link":"/2020/11/01/antDesign-react表单验证注意事项/"},{"title":"antDesign方法默认传值加上其他参数传值","text":"Ant design里面有一些触发方法，如：OnChange,OnClick等等，等到我们触发的时候，这个触发函数就会自动传瑞一些值给方法。比如Switch的OnChange方法调用，即使你什么参数都不传入，也会有一个默认的Boolean值传入，这个布尔值标识现在开关的状态，但是有的时候我们还需要传入一些固定值，也就是我们自己想要传入的值怎么办呢？ 如果以直接写： 1onChange={this.onChange(你要传的参数)} 他会用你要传的参数覆盖掉默认值value，这样你就不能把value传过去。如果写成： 1onChange={this.onChange(value,你要传的参数)} 他会提示你value值没有定义。如果想要将这两个值都传进去的话现阶段有两个方法： 12345//用bind，this后面加上你要的参数，他会把value值传到你写的方法的最后一个参数上onChange={this.onchange.bind(this,你要传的参数)} // 显式地把value写出来，这样就可以把value和参数都传过去onChange={(value)=&gt;{this.onchange(value,你要传的参数)}}","link":"/2020/11/01/antDesign方法默认传值加上其他参数传值/"},{"title":"antdesign实现表格的轮播","text":"我的应用场景是：每5分钟获取一次120条数据，每一次表格显示两条数据，每5s进行轮播一次。如果所有数据都播放完成，将会从头开始轮播，但是一旦请求的数据获取到了，就会打断之前的轮播，进而轮播新的数据。 我们在这里使用的antdesign的表格，稍微将表格的样式进行修改，并去掉了分页，具体的引用如下： 其中dataSource 是表格的数据，根据自己的情况来定，loading是加载动画，可以根据自己的情况进行自定义的定制，columns是表头的设置，可以根据antdesign的说明文档进行详细的了解，因为在我的页面中不需要做分页，所以我将pagination这个属性设置为false。 被模糊掉的是数据的部分。 其中有两点是需要注意的： 两个定时器要是平级的，一般在编码的时候，不能讲定时器进行嵌套，否则会出现时间的紊乱 init 主要的作用就是当请求回来的时候，进行新的数据的轮播 上面的代码我是在componentDidMount里面写的，通过setInterval的方法实现轮播，大家如果有跳转的需求，在组件将要挂载的时候，将上面的定时器清除掉，否则会影响性能。","link":"/2020/11/01/antdesign实现表格的轮播/"},{"title":"antdesign的上传功能使用","text":"我们要实现的是在点击上传按钮的时候，弹出一个对话框，在选择文件的之后点击完成的时候，向指定的地址上传文件 html的相关代码 12345678910&lt;!--html文件--&gt;&lt;!--multiple为true可以同时上传多个文件--&gt;&lt;!--showUploadList 为false不现实文件的上传情况--&gt;&lt;Upload multiple ={true} accept =&apos;.mib&apos; beforeUpload = {this.uploadMibfiles} onChange ={this.fileState} showUploadList = {false}/&gt; js的逻辑代码 1234567891011121314151617// 将获取到的文件进行保存，方便后续进行操作uploadMibfiles = file =&gt;{ this.fileList = file;} fileState = info =&gt;{ if(this.fileListMy &amp;&amp; this.fileListMy.length !== 0){ // 写相关发请求的逻辑 apiUp (this.fileList）.then(res =&gt;{ if (res !== 202){ message.success(&apos;文件上传成功&apos;) }else{ message.errro(&quot;文件上传失败&quot;) } }) }} 发送请求的代码 123456const apiUp = async file =&gt;{ const formData = new FormData(); // 将文件变成键值的形式，可以方便的处理各类的文件 formData .append(&apos;file&apos;,file); const res = await axios.post(&apos;/wdfedf/guyfewj&apos;,formDate); return res;}","link":"/2020/11/01/antdesign的上传功能使用/"},{"title":"async/await原理","text":"我们都知道async/await是Generator函数的语法糖，为了更加深刻的了解async/await的原理，我们先来研究一下Generator的相关的知识。 基本概念Generator：可以被认为是一个状态机，其内部封装了多个内部的状态。执行该函数会返回一个遍历器对象，也就是，Generator函数除了状态，还是一个遍历器对象生成函数，返回的遍历器对象，可以依次遍历Generator内部的每一个状态。 函数特征： function关键字与函数名之间有一个星号 函数内部使用yield表达式，定义不同的内部状态 123456function* foo(){ yield 'hello'; yield 'word'; return 'ending';}var hw = foo(); 上面的代码定义了一个Generator函数，内部由两个yield表达式(hello和world),即将执行的函数有三个状态：hello,world和return语句。 Generator函数调用和普通函数的调用是一样的，也是在函数名后面加上一对圆括号。但是调用Generator调用之后并不执行，返回的也不是函数运行结果，而是指向内部状态的指针对象，也就是上面说的遍历器对象。下一步必须调用遍历对象的next方法，让指针指向下一个状态，也就是说，每一次调用next方法，内部指针就会从函数头或是上一次停下来的地方开始执行，直到遇到下一个yield表达式为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 1234567891011hw.next()// { value: 'hello', done: false }hw.next()// { value: 'world', done: false }hw.next()// { value: 'ending', done: true }hw.next()// { value: undefined, done: true } done属性的值false，表示遍历还没有结束。否则表示遍历已经结束啦。 第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。 在这个过程中，最重要的是next的方法的运行逻辑，下面我们对这个过程进行一下梳理： 遇到yield表达式，先暂停后面的操作，将紧跟着yield后面的表达式的值，作为返回对象的value属性值进行返回 下一次调用next方法的时候，再继续往下执行，知道遇到下一个yield表达式。 如果没有遇到新的yield表达式，就一直运行直到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 如果没有遇到return语句，就会返回对象的value属性值为undefined。 yield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。 异步操作的同步化表达我们举一个例子来实现将异步的操作同步化：过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。 1234567891011121314function* main() { var result = yield request(\"http://some.url\"); var resp = JSON.parse(result); console.log(resp.value);}function request(url) { makeAjaxCall(url, function(response){ it.next(response); });}var it = main();it.next(); makeAjaxCall函数中的next方法，必须加上response参数，因为yield表达式，本身是没有值的，总是等于undefined。 Generator 函数的异步应用ES6诞生以来主要实现异步编程的方法有如下的四种： 回调函数 – 回调地狱 事件监听 发布订阅 Promise 对象 – 代码冗余回调函数JavaScript语言对异步编程的实现，就是回调函数，回调函数，就是把任务的第二阶段单独写在一个函数中，等待重新执行这个任务的时候，就直接调用这个函数，回调函数的英文名字就是callback,直接翻译过来就是”重新调用”1234fs.readFile('/etc/passwd', 'utf-8', function (err, data) { if (err) throw err; console.log(data);}); readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。 Promise回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。 12345fs.readFile(fileA, 'utf-8', function (err, data) { fs.readFile(fileB, 'utf-8', function (err, data) { // ... });}); 会出现多重回调的情况，进而造成代码的可读性变差，形成回调地狱('callback hell') Promise对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件， 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function (data) { console.log(data.toString());}).then(function () { return readFile(fileB);}).then(function (data) { console.log(data.toString());}).catch(function (err) { console.log(err);}); Promise的最大问题是代码冗余，原来的任务被Promise包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。 Generator 函数协程有点像函数，又有点像线程。它的运行流程大致如下。 协程A开始执行。 协程A执行到一半，进入暂停，执行权转移到协程B。 （一段时间后）协程B交还执行权。 协程A恢复执行。 Generator 函数是协程在ES6 的实现，最大特点就是可以交出函数的执行权，下面看看如何使用 Generator函数，执行一个真实的异步任务。 12345678910111213141516var fetch = require('node-fetch');function* gen(){ var url = 'https://api.github.com/users/github'; var result = yield fetch(url); console.log(result.bio);}var g = gen();var result = g.next();result.value.then(function(data){ return data.json();}).then(function(data){ g.next(data);}); async/await前文有一个Generator 函数，依次读取两个文件。 1234567891011121314151617const fs = require('fs');const readFile = function (fileName) { return new Promise(function (resolve, reject) { fs.readFile(fileName, function(error, data) { if (error) return reject(error); resolve(data); }); });};const gen = function* () { const f1 = yield readFile('/etc/fstab'); const f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());}; 上面代码的函数gen可以写成async函数，就是下面这样。 123456const asyncReadFile = async function () { const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());}; async函数就是将Generator函数的星号（*）替换成async，将yield替换成awaitasync函数对 Generator函数的改进 内置执行器。而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 更好的语义async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 更广的适用性。yield命令后面只能是 Thunk 函数或 Promise对象，而async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即resolved 的Promise对象）。 返回值是Promise。 async函数的返回值是 Promise 对象async 函数的实现原理async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。1234567891011async function fn(args) { // ...}// 等同于function fn(args) { return spawn(function* () { // ... });} 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器,我们看一下spawn的执行过程： 12345678910111213141516171819202122function spawn(genF) { return new Promise(function(resolve, reject) { const gen = genF(); function step(nextF) { let next; try { next = nextF(); } catch(e) { return reject(e); } if(next.done) { return resolve(next.value); } Promise.resolve(next.value).then(function(v) { step(function() { return gen.next(v); }); }, function(e) { step(function() { return gen.throw(e); }); }); } step(function() { return gen.next(undefined); }); });}","link":"/2020/11/01/async-await/"},{"title":"git的使用","text":"我们主分支上面提交代码，我们使用git commit的命令进行提交，很简单，我在进行详细的描述。 分支创建分支我们通过实际操作看一下分支是什么样子的，比如说我们先要创建一个名字为newImage的分支。创建分支前： 使用命令 git branch newImage之后 在新的分支上面提交内容当我们向新的分支上面提交一些新的东西，如果我们直接执行git commit。 我们会发现master分支前进了，但是newImage分支还是待在原地。我们仔细看一下上图，我们发现现在在master上面有一个星号，这表示的是我们现在在master分支上面。所以我们正确的操作是，先切换到新分支上面，然后进行提交代码，我们执行的命令是:git checkout newImage ; git commit 分支与合并 merge假如我们现在有两个分支，每一个分支上面都有一个独立的提交记录。这就意味着没有一个分支包含我们所有的修改的内容，我们要将这两个分支进行合并，现在我们看一下分支的情况： 现在我们将bugFix合并到master分支上面，使用命令：git merge bugFix 但是我们希望将master 分支合并到bugFix上面，我们需要先进行分支的切换，然后在进行合并，具体的命令如：git checkout bugFix; git merge master 上面这样执行的是因为master继承自bugFix，多以Git什么都不需要做，知识简单的把bugFix移动到master指向的那个提交记录就可以了。rebase我们要是想将bugFix分支直接移到master分支上面，移动以后会让两个分支的功能看起来像按顺序开发的，但是实际上他们是并行开发的 我们执行git rebase master，现在bugFix的分支上面的工作在master分支的最顶端，我们看一下C3依然存在，而C3’是我们Rebase到master分支上的C3副本，现在的问题是master还没有更新，我们线面进行master分支的更新。 现在我们先切换到master分支上面，把它rebase到bugFix上面，合并的命令：git rebase bugFix 在提交树上移动HEADHEAD是一个对当前检出记录的符号引用– 也就是指向我们正在这个基础上进行工作的提交记录。HEAD总是指向当前分支最近一次的提交情况。HEAD通常情况下指向分支名，在提交的时候，改变了分支的状态，这一改变导致HEAD是可见的。 执行命令：git checkout C1; git checkout master ;git commit; git checkout c2 分离的HEAD分离的HEAD就是让其指向了某一个具体的提交记录，而不再是分支名我们看一下现在的情况是：HEAD指向master，master指向c1 如果我们使用指令git checkout C1 现在的执行变成了：HEAD指向C1相对引用 我们可以使用^向上移动一个提交记录 使用^向移动多个提交记录 我们可以看一下，根据上面的意思也就是master^ 就是master的父节点。所以我们执行命令git checkout master ^ 我们也可以将HEAD作为相对引用的参照，我们现在就举个栗子：执行命令：git checkout C3; git checkout HEAD ^; git checkout HEAD ^; git checkout HEAD ^执行命令前： 执行命令后： 依次上移，直到： ~操作符如果在提交树上向上移动很多步骤的话，要敲很多的^,这样的就很麻烦，Git也考虑到了这一点，于是又引入先操作符~。这个操作符后面可以和一个数字(可选，不跟数字时与^相同，向上移动一次)，指定向上移动多少次。后退之前： 执行：git checkout HEAD~4 我使用相对引用最多的就是移动分支，可以直接使用-f选项让分支指向另一个提交。 git branch -f master HEAD^3:会将master分支强制指向HEAD的第3级父提交。 执行前： 执行后：","link":"/2020/11/01/git的使用/"},{"title":"js的节流和防抖","text":"概念 防抖： 任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。 节流：指定时间间隔内只会执行一次任务。 实现方式防抖的实现方式：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"dobounce\"&gt;点我防抖&lt;/button&gt; &lt;button id=\"throttle\"&gt;点我节流！&lt;/button&gt; &lt;script&gt; window.onload = function() { // 进行 防抖 var myDebounce = document.getElementById(\"dobounce\"); myDebounce.addEventListener(\"click\", dobounce(saydoDounce)); // 进行 节流 var myThrottle = document.getElementById(\"throttle\"); myThrottle.addEventListener(\"click\", throttle); }; // 防抖 function dobounce(fn) { let timeout = null; return function() { clearTimeout(timeout); timeout = setTimeout(() =&gt; { // fn(); // console.log(this) fn.call(this); }, 1000); }; } function saydoDounce() { console.log(this); console.log(\"防抖成功\"); } // 方法一 // 节流 // function throttle(fn){ // let canRun = true; // return function(){ // if(!canRun){ // 在函数开头判断标志是否为 true，不为 true 则中断函数 // return; // } // canRun = false; // setTimeout(()=&gt;{ // fn.call(this); // canRun = true; // },2000) // } // } // 方法二 let canRun = true; function throttle() { // console.log(canRun) if (!canRun) { // 在函数开头判断标志是否为 true，不为 true 则中断函数 return; } canRun = false; setTimeout(() =&gt; { sayThrottle(); canRun = true; }, 5000); } function sayThrottle() { console.log(\"节流成功\"); } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 防抖的代码：这件事儿需要等待，如果你反复催促，我就重新计时！节流的代码：固定时间内只是执行一次 应用场景debounce search搜索联想，用户在不断输入值时，用防抖来节约请求资源。 window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 throttle 鼠标不断点击触发，mousedown(单位时间内只触发一次) 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断","link":"/2020/11/01/js的节流和防抖/"},{"title":"less语法基础","text":"变量（1）可以将属性的值赋值给一个变量，变量为完全的常量，所以只能定义一次 123@pre-blue : #5B83AD;@after-blue :@nice-blue + #111；#header{ color: @after-blue; } 编译过的结果就是: 1#header { color :#6c94be } (2)也可以通过使用变量名定义为变量 123@fnord:'I am Kim'@var: 'fnord';content:@@var 编译过的结果就是: 1content:&apos;I am Kim&apos;; ##混合将一些通用的属性放在一个class中，然后在例外一个class中去调用这些属性。任何的class和id或是元素都可以用这样的方式进行引入。 123456789101112.temp{ border-top: dotted 1px black; border-bottom: solid 2px black;}#header a{ color : #111; .temp;}#nav a{ color : black; .temp;} 编译过的结果就是: 12345678910#header a{ color : #111; border-top: dotted 1px black; border-bottom: solid 2px black;}#nav a{ color : black; border-top: dotted 1px black; border-bottom: solid 2px black;} ##带参数的混合（1）可以像函数一样定义一个带参数的属性集合 12345678910111213.border-radius (@radius) { border-radius: @radius; -moz-border-radius: @radius;-webkit-border-radius: @radius;}#header { .border-radius(4px);}.button { .border-radius(6px); } （2）也可以给参数设置一个默认的值 123456789.border-radius (@radius : 5px) { border-radius: @radius; -moz-border-radius: @radius;-webkit-border-radius: @radius;}#header { .border-radius(4px);} （3）也可以定义不带参数的属性集合，用于隐藏这个属性集合，不让它暴露到CSS中去。 12345678.wrap () { text-wrap: wrap; white-space: pre-wrap; white-space: -moz-pre-wrap; word-wrap: break-word;}pre { .wrap } 编译后的结果是： 123456pre { text-wrap: wrap; white-space: pre-wrap; white-space: -moz-pre-wrap; word-wrap: break-word;} （4）arguments包含了所有的传递进来的参数，不用单独处理每一个参数 123456.box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) { box-shadow: @arguments; -moz-box-shadow: @arguments; -webkit-box-shadow: @arguments;}.box-shadow(2px, 5px); 编译过后的结果是： 12345.box-shadow{ box-shadow: 2px 5px 1px #000; -moz-box-shadow: 2px 5px 1px #000; -webkit-box-shadow: 2px 5px 1px #000;} 模式匹配可以通过值的进行匹配，也可以通过参数的个数进行匹配 1234567891011121314151617//让.mixin根据不同的@switch值而表现各异.mixin (dark, @color) { color: darken(@color, 10%);}.mixin (light, @color) { color: lighten(@color, 10%);}.mixin (@_, @color) { display: block;}//运行@switch: light;.class { .mixin(@switch, #888);} 经过编译后的颜色是： 123456789101112.class { color: #a2a2a2; display: block;}/*mixin就会得到传入颜色的浅色。如果@switch设为dark，就会得到深色。具体实现如下：第一个混合定义并未被匹配，因为它只接受dark做为首参第二个混合定义被成功匹配，因为它只接受light第三个混合定义被成功匹配，因为它接受任意值只有被匹配的混合才会被使用。变量可以匹配任意的传入值，而变量以外的固定值就仅仅匹配与其相等的*/ 导引表达式（1）根据表达式进行匹配，而不是通过值和参数匹配 1234567891011121314//when关键字用以定义一个导引序列(此例只有一个导引).mixin (@a) when (lightness(@a) &gt;= 50%) { background-color: black;}.mixin (@a) when (lightness(@a) &lt; 50%) { background-color: white;}.mixin (@a) { color: @a;}//运行.class1 { .mixin(#ddd) }.class2 { .mixin(#555) } 编译后的结果是： 12345678.class1 { background-color: black; color: #ddd;}.class2 { background-color: white; color: #555;} (2)导引中可用的全部的比较运算符有:&gt; &gt;= =&lt; &lt;。此外，关键字true只表示布尔真值，除去关键字true以外的值都被视为布尔假值。(3)导引序列使用逗号‘，’分割，当且仅当所有的条件都符合的时候，才会被视为匹配成功。 1.minin(@a) when (@a &gt;10),(@a &lt; 100){...} (4)导引可以没有参数，也可以对参数进行比较运算 1234567@media: mobile;.mixin (@a) when (@media = mobile) { ... }.mixin (@a) when (@media = desktop) { ... }.max (@a, @b) when (@a &gt; @b) { width: @a }.max (@a, @b) when (@a &lt; @b) { width: @b } (5)如果想要基于值的类型进行匹配的话，可以使用is表达式进行判断 12.mixin (@a, @b: 0) when (isnumber(@b)) { ... }.mixin (@a, @b: black) when (iscolor(@b)) { ... } 常见的检测函式：iscolor、isnumber、isstring、iskeyword、isurl判断一个值是纯数字，还是某个单位量，可以使用下列函式：ispixel、ispercentage、isem(6)使用and和not关键字实现与条件 12.mixin(@a) when (isnumber (@a) ) and (@a &gt; 0) {...}.mixin(@b) when not ( @b &gt; 0){...} 嵌套规则（1）以嵌套的方式写层叠样式 12345678910#header { color: black; }#header .navigation { font-size: 12px;}#header .logo { width: 300px; }#header .logo:hover { text-decoration: none;} 可以改写成用less语法进行,其中&amp;符号用于写串联选择器，这一点对于伪类选择器有很大的作用。 1234567891011#header { color: black; .navigation { font-size: 12px; } .logo { width: 300px; &amp;:hover { text-decoration: none } }} 运算（1）任何数字、颜色都可以参与运算 1234567@base : 10%;@filter : @base * 2;@other : @base + @filter;color : #888 / 4;background-color : @base=color + #111;height : 100% / 2 + filterl; （2）less运算能够分辨颜色和单位 123@var : 1px + 5; //6pxwidth : (@var + 5 ) *2; //被允许使用括号border: (@width * 2) solid black; // 可以在符合属性中进行使用 函数（1）less本身提供了一系列的颜色运算函数。颜色会被转化成为HSL色彩空间，然后在通道级别操作。 12345678910lighten(@color, 10%); // 返回一个比@color低10％更轻的颜色darken(@color, 10%); // 返回一个比@color高10％较暗的颜色saturate(@color, 10%); // 返回比@color多饱和度10％的颜色desaturate(@color, 10%); // 返回一个比@color少饱和度10％的颜色fadein(@color, 10%); // 返回一个比@color少10％透明度的颜色fadeout(@color, 10%); // 返回一个比@color多10％透明度的颜色fade(@color, 50%); // 返回一个颜色透明度为50％的颜色spin(@color, 10); // 返回色调比@color大10度的颜色spin(@color, -10); // 返回一个比@color小10度色调的颜色mix(@color1, @color2); // 返回一个混合@ color1和@ color2的颜色 举个小栗子： 12345@base: #f04615;.class { color: saturate(@base, 5%); background-color: lighten(spin(@base, 8), 25%);} （2）可以获取颜色的具体参数 123hue(@color) //获取色相saturation(@color) //获取饱和度lightness(@color) //获取明度 (3)也可以在一种颜色的通道上面创建另外一种颜色,@new 将会保持 @old的 色调, 但是具有不同的饱和度和亮度. 1@new: hsl(hue(@old), 45%, 90%); Math函数less提供了一组方便的数学函数，可以使用它们处理一些数字类型的值。 1234round(1.67); // returns `2`ceil(2.4); // returns `3`floor(2.6); // returns `2`percentage(0.5); // returns `50%` 命名空间有时候，我们可能更好地组织CSS或是单纯的为了更好地封装，我们会将会一些变量或是混合模块进行打包操作，为了后续进行复用 12345678910#bundle { .button () { display: block; border: 1px solid black; background-color: grey; &amp;:hover { background-color: white } } .tab { ... } .citation { ... }} 当我们想要在某一个地方引入button的样式的时候： 1234#header a { color: orange; #bundle &gt; .button;} 作用域less的作用域和其他编程语言十分的相似，首先在本地的变量和混合模块进行查找，如果没有找到的话，就会去父及作用域查找，直到找到为止。 123456789101112@var: red;#page { @var: white; #header { color: @var; // white }}#footer { color: @var; // red } importing(导入)我们如果想要引入less文件，.less的后缀可以有可以没有 12@import &quot;lib.less&quot;;@import &quot;lib&quot;; 但是想要导入一个CSS文件而且不希望less对它进行处理，只要加上CSS后缀就可以了。这样的话less就可以跳过，不去处理他了。 1import &quot;lib.css&quot;; 字符串插值变量可以用类似ruby和php的方式嵌入到字符串中，像@{name}这样的结构 12@base-url: \"http://assets.fnord.com\";background-image: url(\"@{base-url}/images/bg.png\"); 避免编译有时候我们需要输出一些不正确的CSS语法或者使用一些 less不认识的专有语法。要输出这样的值我们可以在字符串前加上一个 ~，并将要避免编译的值用 “”包含起来。 123.class { filter: ~\"ms:alwaysHasItsOwnSyntax.For.Stuff()\";} 结果是： 123.class { filter: ms:alwaysHasItsOwnSyntax.For.Stuff();} JavaScript表达式（1）JavaScript 表达式也可以在.less 文件中使用. 可以通过反引号的方式使用: 1@var: `\"hello\".toUpperCase() + '!'`; // @var :\"HELLO!\" （2）也可以同时使用字符串插值和避免编译 12@str: &quot;hello&quot;;@var: ~`&quot;@{str}&quot;.toUpperCase() + &apos;!&apos;`; //@var: HELLO!; （3）可以访问JavaScript的环境 1@height: `document.body.clientHeight`; （4）将一个JavaScript字符串解析成16进制的颜色值，可以使用 color 函数 12@color: color(`window.colors.baseColor`);@darkcolor: darken(@color, 10%); 参考：less一种 动态 样式 语言","link":"/2020/11/01/less语法基础/"},{"title":"mock的配置","text":"Mock.js 是一款前端开发中拦截Ajax请求再生成随机数据响应的工具.可以用来模拟服务器响应. 优点是非常简单方便, 无侵入性, 基本覆盖常用的接口数据类型. 安装mock 对webpack进行配置webpack.dev.config.js mock/indx.js的使用利用webpack-dev-server 的before 方法调用webpack-api-mocker。path.resolve(‘./mocker/index.js’) 中的’./mocker/index.js’为mock文件的相对 对于已经在webpack中配置public路径的童鞋注意：要在拦截url的前面加上publicurl的路径值 http://www.liubeijing.ren/article/detail/article_id/99.html","link":"/2020/11/01/mock的配置/"},{"title":"moment的中文显示","text":"我在使用moment的时候，想要让时间戳转换的格式变成XXXX年XX月XX日 XX:XX:XX 星期X 这个格式 但是这个默认转换是英文 所以我们要做的操作是引入一个中文的文档：","link":"/2020/11/01/moment的中文显示/"},{"title":"react组件的渲染","text":"React有三种定义组件的方式，但是在实现上是殊途同归，具体的方式如下： 函数式定义的无状态组件 es5 原生的使用React.createClass定义的组件 es6 形式的extends React.Component 定义的组件 无状态组件无状态组件一般的用途就是纯展示组件，这种之间只负责传入的props来展示，不涉及state的状态操作。具体的无状态函数组件，在官方文档中支出是：在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。无状态函数组件的组成形式上面只有一个render方法的组件类，通过函数形式或是ES6箭头函数的形式在创建，并且在这个之间是无state的。我们先举个小栗子： 1234function HelloComponent(props, /* context */) { return &lt;div&gt;Hello {props.name}&lt;/div&gt;}ReactDOM.render(&lt;HelloComponent name=&quot;Sebastian&quot; /&gt;,Node) 我们看一下上面的代码，可以看出无状态组件的形式代码的可读性会更好，并且减少了大量的冗余的代码，精简至只需要一个render方法，大大增强了编写组件的遍历，除此之外还有以下几个显著的特点： 组件不会被实例化，整体渲染的性能的得到了提升我们对组件的实现仅仅依靠一个render函数来进行实现，因为是没有状态的，所以也就不存在组件实例化的过程，无实例化过程也就说明了，组件是不需要进行多余的内存分配的，所以性能上会有一定的优化 组件是不能访问this的 我们在进行组件封装的时候，在原理上面一般是先对这个类进行实例化，let a = new A()类似这样的过程，然后this指向的a,但是纯函数的话也就不存在这个过程了。 组件没有办法访问声明周期的方法因为无状态组件是不需要组件声明周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。 无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用这也就意味着我们使用纯函数的方法来写组件的话，这个组件的作用一般来说就是进行界面的显示。 无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以只要有可能，尽量使用无状态组件。 React.ComponentReact.Component是以ES6的形式来创建react的组件的。 1234567891011121314151617181920212223242526272829303132333435class InputControlES6 extends React.Component { constructor(props) { super(props); // 设置 initial state this.state = { text: props.initialValue || &apos;placeholder&apos; }; // ES6 类中函数必须手动绑定 this.handleChange = this.handleChange.bind(this); } handleChange(event) { this.setState({ text: event.target.value }); } render() { return ( &lt;div&gt; Type something: &lt;input onChange={this.handleChange} value={this.state.text} /&gt; &lt;/div&gt; ); }}InputControlES6.propTypes = { initialValue: React.PropTypes.string};InputControlES6.defaultProps = { initialValue: &apos;&apos;}; React.createClass123456789101112131415161718192021222324252627282930313233var InputControlES5 = React.createClass({ propTypes: {//定义传入props中的属性各种类型 initialValue: React.PropTypes.string }, defaultProps: { //组件默认的props对象 initialValue: &apos;&apos; }, // 设置 initial state getInitialState: function() {//组件相关的状态对象 return { text: this.props.initialValue || &apos;placeholder&apos; }; }, handleChange: function(event) { this.setState({ //this represents react component instance text: event.target.value }); }, render: function() { return ( &lt;div&gt; Type something: &lt;input onChange={this.handleChange} value={this.state.text} /&gt; &lt;/div&gt; ); }});InputControlES6.propTypes = { initialValue: React.PropTypes.string};InputControlES6.defaultProps = { initialValue: &apos;&apos;}; 可以访问组件的生命周期方法但是随着React的发展","link":"/2020/11/01/react组件的渲染/"},{"title":"react的状态管理","text":"在使用react的状态管理的过程，如果我们不使用封装好的状态管理工具的话，我们就需要对state进行状态的提升的时候就会涉及到两种情况： 父组件向子组件传值 子组件向父组件传值 首先，我们先看一下父组件如何向子组件传递值，这个方式很简单，就是直接从父组件以props的方式传递到子组件中。 这个时候，我们引入父组件的方式，假设父组件是一个form的表单，子组件是一个自己封装的名为BackupTime的子组件在父组件中： 123456789101112131415import BackupTime from './BackupTime.js'class Parent extend Component {data ={a:1} render(){ return ( &lt;Form&gt; &lt;FormItem&gt; &lt;BackupTime choice ={this.data} /&gt; &lt;/FormItem&gt; &lt;/From&gt; ) }} 在子组件中： 12345class BackupTime extends Component { compnentDidMount(){ const {choice} = this.props }} 这样就简单的实现了父组件向子组件传值的过程，那么如何实现子组件向父组件传值呢，比如说 我的子组件有一个下拉框，在子组件修改了这个下拉框的值，但是我们要在父组件中得到相对应的下拉框的值。 上面的场景可以概括为，子组件的下拉框发生改变的时候，父组件的在点击click按钮的时候，可以将子组件的select选中的数据打出 123456789101112131415161718192021import BackupTime from './BackupTime.js'class Parent extend Component { state ={select:''} handleSubmit =() =&gt;{ console.log(this.state.select) } getValue = (value) =&gt;{ this.setState({select:value}) } render(){ return ( &lt;Form&gt; &lt;FormItem&gt; &lt;BackupTime choice ={this.data} getValue ={this.getValue }/&gt; &lt;Button onClick={this.handleSubmit} /&gt; &lt;/FormItem&gt; &lt;/From&gt; ) }} 在子组件中： 12345678910class BackupTime extends Component { compnentDidMount(){ const {choice} = this.props } render(){ return ( &lt;select onChange ={value =&gt;this.props.getValue(value)}/&gt; ) }} 然后我们再来扩展一下我们有三种写函数的方法 12const A (){....} // 方法一A = () =&gt;{....} // 方法二 上面的两种函数的写法，主要体现在this的引用上面，方法一是谁调用函数，this就指向谁，方法二是需要看上下文我们在react的组件中调用方法的写法有三种，我们来看一下 123&lt;Button onClick = {this.A}&gt; // 方法一&lt;Button onClick = {(value)=&gt;this.A(value)}&gt; //方法二&lt;Button onClick = {this.A()}&gt; //方法三 对于方法一来说 onClick 等价于this.A这个方法，所以在这个过程中，并不会执行A的这个方法方法二和方法一很相似，但是 这个里面可能需要传入除了组件默认传的值之外的值，我们使用了一个匿名函数包裹了A函数，所以这个A还是也是不会被立即执行的。方法三，我们在render进行渲染的时候，就直接的调用了上面的这个方法，这个情况用于闭包较多。 ps:对于所有的复杂类型都是有__proto__属性，但是只有是原生方法才会有protoType这个属性，箭头方法也是没有protoType这个属性的，构造方法一般挂在protoType这个属性上面。所以，对于需要new的方法是没有办法使用箭头函数的。 导出文件的时候：export default {A} :这种方式导出的组件是没有名字的，所以在引用的时候，需要对其进行重命名export {A}：这种方式进行导出的话，由于是有名字的，所以在导出的时候要加{},相当于对变量的结构 对类型判断的时候，尽量使用Array.isArray()方法，避免使用instance of方法，因为instance of取到的时候原型上面的东西，如果被别人不小心修改了，容易出现错误在react中 1234567891011class BackupTime extends Component { A(){} // 原型上的方法 B =() =&gt;{} // 实例方法,重点在于那个等于号 B = function(){} // 实例方法 static C (){} // 静态方法 render(){ return ( &lt;select onChange ={value =&gt;this.props.getValue(value)}/&gt; ) }}","link":"/2020/11/01/react的状态管理/"},{"title":"react给axios请求配置统一的header","text":"我们在开发的过程中，需要统一在请求上添加请求头。比如说我们要在请求中添加用户的Id。 第一步：先建一个文件夹，在这个文件夹中建一个http.js文件 12345import axios from 'axios'; const init=function(){ axios.defaults.headers.common['user'] = '111';}export default {init} 第二步：在App，也就是项目启动的文件中的render函数中调用这个方法 1234import httpTest from './http.js'render(){ httpTest.init();} 这样的话，在下面直接调用axios进行发送请求的时候就会直接在发送的请求上面拼接我们需要的内容了。","link":"/2020/11/01/react给axios请求配置统一的header/"},{"title":"redux的入门","text":"ActionAction本质上是JavaScript普通对象，我们约定，action内使用一个字符串类型的type字段表示要执行的动作。多数情况下，type会被定义成字符串常量。另外，当应用规模越来越大时，建议使用单独的模块或文件来存放action。除了type字段外，action对象的结构完全由我们自己决定。 123store.dispatch({type:&apos;INCREMENT&apos;});store.dispatch({type:&apos;INCREMENT&apos;});store.dispatch({type:&apos;DECREMENT&apos;}); ReducerReducer是个形式为(state,action)=&gt;state的纯函数，描述了action如何把state转变成下一个state。 123456789101112131415function counter(state = 0,action){ switch(action.type){ case &apos;INCREMENT&apos;: return state + 1; case &apos;DECREMENT&apos;: return state - 1; default: return state; }}我们输出的结果是：pre state:0 next state :1pre state:1 next state :2pre state:2 next state :1 纯函数纯函数：输入/输出数据流都是显式的（显式：函数与外界交换数据只有一个唯一渠道–参数和返回值）函数从函数外接受的所有输入信息都通过参数传递到该函数的内部；函数输出到函数外部的所有信息都通过返回值传递到函数外部。纯函数不能访问外部的变量，它能接触的‘外地人’只有来自外部的参数。纯函数不能修改参数，因为这样做可能会把一些信息通过输入参数，夹带到外界。在reducer函数中不能进行如下的参数： 修改传入的参数 执行有副作用的操作，如：API请求和路由跳转 调用非纯函数，如Date.now()或Math.random()不能修改参数state假如我们尝试一下修改state并返回，如下面的代码：123456789101112Counter = (state = 0,action) =&gt; { switch (action.type){ case &apos;INCREMENT&apos;: state++; return state; case &apos;INCREMENT&apos;: state--; return state; default: return state; }} 运行后发现，并没有报错，打印的结果和之前一样，这样的话，我们就会考虑是不是我们的规则有问题，而其实这种情况只是一种侥幸。当state是对象的时候，修改参数state会影响程序的变更追踪。如果后面使用了react-redux将Redux程序连接到UI组件上，你的组件将不能更新，因为react-redux无法察觉到任何state变化。为什么会发生这样的问题？因为在JavaScript中，对象是引用类型，当我们改变state，变化前后的两个state就会指向一个地址，react-redux就会以为这是两个相同的state，因而不会执行渲染。让我们将state给为对象类型，我们看一下这个违规的行为带来的后果： 123456789101112Counter = (state ={val:0},action) =&gt; { switch (action.type){ case &apos;INCREMENT&apos;: state.val++; return state; case &apos;INCREMENT&apos;: state.val--; return state; default: return state; }} 这个时候我们再一次对state的值进行打印，我们发现结果发生了改变：pre state:{val:1} next state :{val:1}pre state:{val:2} next state :{val:2}pre state:{val:1} next state :{val:1} StoreStore是一个全局的对象，将action和reduce以及state联系到了一起。store有以下的职能： 维持应用的state 提供getState()方法获取state 提供dispatch(action)方法更新state 通过subscribe(listener)注册监听器 创建创建store需要从redux包中导入createStore这个方法： 1import {createStore} from &apos;redux&apos; 使用reducer纯函数作为第一个参数创建store： 1let store = createStore(Counter); 这个例子中只有一个参数，但是可以将初始state作为第二个参数传入。修改app.js中的createStore函数，添加第二个参数100作为初始state。 1let store = createStore(Counter,100); 我们输出的结果是：pre state:100 next state :101pre state:101 next state :102pre state:102 next state :101 获取与监听在上面我们创建完store，使用它获取数据，并监听变化： 12345678const store = createStore(Counter);let currentValue = store.getState(); store.subscribe(()=&gt;{ const previousValue = currentValue; currentValue = store.getState(); console.log(&apos;pre state:&apos;, previousValue, &apos;next state:&apos; ,currentValue ); }); 上面的代码做了这样的几件事： 获取初始化的state到currentValue。 使用store.subscribe()方法监听变化 在store.subscribe()的回调函数中，将currentValue传给previousValue作为先前的state 获取更新后的state到currentValue当做当前的state 打印变化前后的state 所以我们的输出的结果就是：pre state:0 next state :1pre state:1 next state :2pre state:2 next state :1 发起action对于store来说使用dispatch(action)方法发起action，更新state： 123store.dispatch({type:&apos;INCREMENT&apos;});store.dispatch({type:&apos;INCREMENT&apos;});store.dispatch({type:&apos;DECREMENT&apos;}); 当发起action后，就将action传进了store中，使用reducer纯函数执行更新。改变内部state唯一方法是dispatch一个action。这样确保了视图和网络请求都不能直接修改state，相反它们只能表达想要修改的意愿，也就是dispatch一个action。 上面的代码我们写一下完整版的代码： 123456789101112131415161718192021222324252627import {createStore} from &apos;redux&apos;;Counter = (state ={val:0},action) =&gt; { switch (action.type){ case &apos;INCREMENT&apos;: state.val++; return state; case &apos;INCREMENT&apos;: state.val--; return state; default: return state; }}let currentValue = store.getState(); const listener = ()=&gt;{ const previousValue = currentValue; currentValue = store.getState(); console.log(&apos;pre state:&apos;, previousValue, &apos;next state:&apos; ,currentValue ); }store.subscribe(listener);store.dispatch({type:&apos;INCREMENT&apos;});store.dispatch({type:&apos;INCREMENT&apos;});store.dispatch({type:&apos;DECREMENT&apos;});","link":"/2020/11/01/redux的入门/"},{"title":"webpack-CSS和file的加载","text":"我们之前一节都是对一些js的资源进行打包，但是如果我们的项目中还有一些其他的资源呢？比如说：images。 在webpack中除了可以引入JavaScript，还可以通过loader引入其他类型的文件。主要的实现是使用loader来实现的。加载各类资源用到的module 加载css文件需要 style-loader css-loader 字体和图片需要 file-loader CSV、TSV和XML 需要csv-loader和xml-loader 安装 现在对代码进行修改后 加载CSS为了在JavaScript模块中的import一个CSS文件，需要安装 style-loader 和 css-loader这两个插件，在module的配置中添加这些loader 1npm install --save-dev style-loader css-loader 并在webpack.config.js的文件中的module进行相关的修改： 添加一个css文件，用来使用样式 对index的文档也进行相对应的修改 加载images图像在加载css的时候，我们也可能需要background会让icon这样的图片，但是我们要要如何处理呢？在这个部分我们使用的是file-loader，我们就可以将这些内容混合到css里面了。 1npm install --save-dev file-loader 对webpack的配置如下： 我们尝试向项目中添加一个图像，看看它具体是如何工作的，现在项目中添加一个图片： 然后执行打包的命令，打包成功后可以在网页中看到该界面。 加载数据有的时候我们请求的资源或是数据是内置，如JSON文件，CSV，TSV和XML。我们有一个例子比如说我们要本地的json文件，因为加载CSV、TSV和XML需要用到CSV-loader和xml-loader，让我们来加载这三类文件。 1npm install --save-dev csv-loader xml-loader 现在在项目目录添加一个data.xml文档： 可以 import 这四种类型的数据(JSON, CSV, TSV, XML)中的任何一种，所导入的 Data 变量，将包含可直接使用的已解析 JSON： 执行npm run build然后打开index.html,在控制台看一下打出控制台，我们可以看到导入的结果。","link":"/2020/11/01/webpack-CSS和file的加载/"},{"title":"webpack-treeShaking","text":"添加一个通用模块假设我们在项目中添加一个新的通用模块的文件math.js，并且导出了两个函数： 然后我们将模式设置为development来确定bundle 是未压缩版本。 然后对现在的index.js的文档进行修改： 注意，我们没有从 src/math.js模块中 import另外一个 square方法。这个函数就是所谓的“未引用代码(dead code)”，也就是说，应该删除掉未被引用的export。现在运行npm script npm run build，并查看输出的bundle： 上面的没有使用的square方法虽然没有使用过，但是他还是被打在了包里面。 将文件标记为 side-effect-free(无副作用)123456{ &quot;name&quot;: &quot;your-project&quot;, &quot;sideEffects&quot;: [ &quot;./src/some-side-effectful-file.js&quot; ]} “./src/some-side-effectful-file.js”这个文件将会被自动的打到保重，进行优化的时候，不会将它删除。","link":"/2020/11/01/webpack-treeShaking/"},{"title":"webpack-安装","text":"安装webpack我现在本地搭建一个项目，来研究webpack的用法，先用git bash 新建一个项目，这样的目的是为了生成一个package.json的文件，有了这个包我们才可以进行后续的装包。 123npm init -y // 如果没有额外的消息要写的话// 可以添加-y参数，想要进行详细的配置的话可以去掉-y 执行后我们得到的项目目录为： 12npm install --save-dev webpack // 直接安装npm install --save-dev webpack@&lt;version&gt; // 指定版本进行安装 安装过之后，然后按照要求新建两个文件，现在的项目目录如下： 对index.js和index.html进行编写，编写的内容如下： 对package.json进行调整 创造一个bundle我们将上面项目进行目录调整，调整的结果为： 我们为了避免断网的情况，将loash的依赖安装进来，安装lodash依赖的语句是： 1npm install --save lodash 我们现在看一下修改过目录结构之后，我们的代码变成了如下的样式： 我删除了上面显示的引入&lt;script src=&quot;https://unpkg.com/lodash@4.16.6&quot;&gt;&lt;/script&gt;这一行的代码，然后将index.js 改成了main.js,然后执行npx webpack 打包成功后访问，在浏览器中打开index.html，如果一切正常，你应该能看到以下文本：Hello webpack。当然在打包过程中会有一定的警告 ，但是这并不影响使用。 使用配置文档先添加一个用来配置webpack的配置文档 配置文档的内容如下： 然后我们执行命令npx webpack --config webpack.config.js来打包这个文档，打包成功，在界面上显示Hello webpack的字样。 npm scripts我们可以对指定的命令进行封装 这样的话我们就可以不使用npx webpack 而是npm build","link":"/2020/11/01/webpack-安装/"},{"title":"webpack-开发环境","text":"开发环境 我们在webpack的配置文件中将mode设置成development,具体的代码如下： source map当我们使用webpack打包源代码的时候，可能会很难最终到error和warning的位置，例如，我们现在有三个源文件打包到了一个bundle中，而其中有一个源文件错误了，那么报错的时候，会直接指向bundle.js 。我们想要准确的知道错误来自某一个源文件，这样的提示信息往往没有什么实际意义。为了我们可以更加轻松的追踪错误和警告，JavaScript提供了source map功能，可以将编译后的代码映射到原始源代码。我们看一下下一个例子。首先对webpack的配置文件进行配置： 然后我们在print.js里面的代码在语法上有错误 然后我们进行打包，我们成功打包之后我们点击按钮，点击后在控制台会输出如下的错误： 方便我们进行简单的错误定位。 webpack watch mode(webpack 观察模式) webpack-dev-server（最可能被用到） webpack-dev-middlewarewatch mode(观察模式)如果其中一个文件被更新，代码将被重新编译，所以你不必再去手动运行整个构建。但是这里需要我们手动的启动webpack watch mode的npm scripts我们看一下这里是如何进行配置的： 现在我们执行命令npm run watch 我们会进入到watch模式下，但是和build指令不同，这个执行没有退出，也就是我们还在一直处于被监控的状态，我们在修改文件，点击保存的时候，就会直接进行编译。 使用 webpack-dev-server我们看一下我们应该怎么使用，首先我们需要先安装一下。 1npm install --save-dev webpack-dev-server 在webpack的配置文件中进行配置： 上面怎么配置的意思是将dist目录下的文件serve到localhost:8000下，这个时候我们可以添加一个可以直接运行dev serve的script，在package.json中 现在，在命令行中运行 npm start，我们会看到浏览器自动加载页面。如果你更改任何源文件并保存它们，web server 将在编译代码后自动重新加载 使用 webpack-dev-middlewarewebpack-dev-middleware 是一个封装器(wrapper)，它可以把webpack 处理过的文件发送到一个 server。 webpack-dev-server 在内部使用了它，然而它也可以作为一个单独的 package 来使用，以便根据需求进行更多自定义设置。下面是一个 webpack-dev-middleware 配合 express server 的示例。 首先我们需要先安装express和webpack-dev-middleware因为我的网速比较慢，这里我是使用yarn 来进行安装的，安装的命令为： 1yarn add express webpack-dev-middleware 接下来我们调整webpack的配置文件，确保middleware 功能是可以正常使用的 我们在脚本中使用了publicPath,用来确认资源文件可以正确的在http://localhost:3000，我们也可以指定port number，下面我们自定义express server： 先创建一个项目目录： 然后我们添加一个npm script，让我们可以方便的运行服务： 我们执行npm run server 的时候，成功之后，我们访问http://localhost:3000就看到了我们写的界面。","link":"/2020/11/01/webpack-开发环境/"},{"title":"webpack-模块热替换","text":"模块热替换(HMR)这个功能允许在运行时更新所有类型的模块，而不是完全刷新。但是HMR不适合生产环境，也就是说它更加多的应用于开发环境。 启用HMR我想要启用HMR首先要做的就是更新webpack-dev-server,然后在webpack内置HMR的插件，还要删掉print的入口奇点，因为现在已经在index.js模块中引用了。 也可以通过命令来进行上述的修改 webpack-dev-server --hotOnly。现在修改index.js文件，当print.js内部发生变更的时候，告诉webpack接受模块的变更 HMR加载样式我们先对webpack的配置文件进行修改,让我们的项目可以进行样式的加载： 在项目中添加一个index.less的代码。我们看一下现在的项目目录： 现在我们使用npm start进行项目的启动，我们发现现在我更新颜色，点击保存，网页上的颜色就自动的修改了。","link":"/2020/11/01/webpack-模块热替换/"},{"title":"webpack-生产环境","text":"我们对生产环境和开发环境进行了略微的区分，但是要遵循不重复的原则，所以需要保留一个common的配置，为了讲这些配置合并在一起，需要使用一个工具webpack-merge,此工具会引用 common&quot;配置，因此我们不必再在环境特定(environment-specific)的配置中编写重复代码。 安装1npm install --save-dev webpack-merge 将项目目录修改为如下的结构： 目录中的具体内容： 在 webpack.common.js 中，设置了入口和出口的配置，并且在其中引入了二者都需要引入的插件。我们在webpack.dev.js 中，我们将 mode 设置为 development，并且为此环境添加了推荐的 devtool（强大的 source map）和简单的 devServer 配置。最后，在 webpack.prod.js 中，我们将 mode设置为 production，其中会引入之前在 tree shaking 指南中介绍过的 TerserPlugin。 在环境特定的配置中使用merge()功能，可以很方便地引用 dev 和prod 中公用的 common 配置。webpack-merge 工具提供了各种 merge(合并) 高级功能，但是在我们的用例中，无需用到这些功能。 npm scripts把 scripts 重新指向到新配置。让 npm start script中 webpack-dev-server 使用 development(开发环境) 配置文件，而让 npm run build script 使用 production(生产环境) 配置文件","link":"/2020/11/01/webpack-生产环境/"},{"title":"webpack-管理输出","text":"资源输出我们先来看一下我们的项目目录，我们新建了一个print.js的项目文档： 我们现在在print.js的文档中添加一些业务逻辑： 然后我们在index.js文件中使用这个函数： 然后更新index.html的文档，用来为webpack分离入口做准备： 对设置进行调整，我们将在entry添加src/print.js作为新的的入口起点（print），然后修改output，一遍根据入口奇点定义的名称，动态的更改bundle的名称 这个时候我们可以看到webpack生成print.bundle.js和app.bundle.js文件，这个也是我们在index.html文件中指定的文件名称相对应，如果我们在浏览器中打开index.html,就会出现一个按钮，我们点击按钮的时候，会在控制台输出一些信息。但是当我们有一个新的诉求，我们更改我们的一个入口奇点的名称，甚至是添加一个新的入口，会发生什么呢？会在构建的时候重新命名生成的bundle,但是我们在index.html文件中依旧引用的是旧的名称，让我们在HtmlWebpackPlugin来解决这个问题， HtmlWebpackPlugin首先我们先要安装一个插件。并且将webpack.config.js的文档进行调整： 1npm install --save-dev html-webpack-plugin 我们对webpack进行相对应的配置 我们在构建之前，在dist的文件夹中已经有了index.html的这个文件，然而HtmlWebpackPlugin还会默认生成自己的index.html文件，也就是说，它会用新的index.html文件替换我们原来的文件，现在我们执行以下npm run build后看一下究竟会发生什么： 这个是默认生成的index.html的文档，它将我们之前的index.html文档覆盖掉了。 清理 /dist 文件夹我们由于多次的编译，现在的文件夹dist文件夹中的内容十分的杂乱。webpack将生成的文件放在了/文件夹中，但是他不会最终哪些资源在项目中应用，所以我们比较推荐的做法是，每一次生成的之前，先清理一下dist的文件夹，这样就会生成有用的文件，我们现在在下面实现一下这个场景：这里我使用了最近比较流行的插件，来配置和安装他。 1npm install --save-dev clean-webpack-plugin 对webpack进行相应的 这是执行之前build命令之前的项目的文件目录：","link":"/2020/11/01/webpack-管理输出/"},{"title":"webpack学习之devServer","text":"我们在开发的时候，如果只是进行简单的配置，那么我们每一次修改代码，都要手动的进行打包，然后手动的刷新浏览器，这样的话，开发的效率会很低，所以我们这个时候就要想webpack是否可以为我们提供一种方式让webpack帮助我们完成上面的操作，而不是依靠手动进行处理。 监听的方法在package.json进行相关的配置： 123\"scripts\": { \"watch\": \"webpack --watch\",}, 进行上面的配置后后，执行命令npm run watch我们就会直接监听源代码，当源代码发生改变，会自动为我们重新打包。 webpack-dev-server我们有的时候期望，我们不仅仅可以直接监听变化的时候进行重新打包，并创建一个服务，在浏览器上的表现是自动刷新浏览器。 123456789module.exports = { mode: 'development', devtool: 'chep-module-eval-source-map', devServer: { contentBase: './dist', open: true, // 会自动打开一个浏览器 proxy: 8000 },} 在package.json进行相关的配置： 123\"scripts\": { \"start\": \"webpack-dev-server\",}, 我们为什么要创建一个服务：因为我们直接在本地通过文件协议的方式，是没有办法发送ajax的请求的。 自己配置node的书写方式，进行其服务在package.json进行相关的配置： 123\"scripts\": { \"server\": \"node server.js\"}, 我们需要先安装一个中间件：webpack-dev-middleware并在package.json 同级目录中，写一个server.js的文件 12345678910111213141516171819const express = require('express');const webpack = require('webpack'); // 引入了webpack的库const webpackDevMiddleware = require('webpack-dev-middleware');const config = require('./webpack.config.js'); // 引入了webpack的配置文件const complier = webpack(config); // 使用webpack和配置文件，可以随时的进行代码的编译// 在node中使用wenpackconst app = express();// 只要文件发生了改变，complier就会重新进行打包，打包后的文件放在publicPath路径下app.use( webpackDevMiddleware(complier, { publicPath: config.output.publicPath }));app.listen(3000, () =&gt; { console.log('server is running');});","link":"/2020/11/01/webpack学习之devServer/"},{"title":"webpack学习之loader","text":"loader的作用用来将webpack无法处理的东西。转换成webpack可以处理的东西，webpack理论上只可以处理js的语言。 test:loader用来处理哪些文件，这个部分一般使用正则来表示 use：将满足的条件进行转换的时候，使用的是哪个loader 12345678910111213141516171819202122232425262728293031module: { rules: [ { test: /\\.(jpg|png)$/, // 用正则标识对哪些文件进行处理 use: { // 对于满足正则的文件使用什么loader，这个loader需要通过npm 进行安装 loader: 'file-loader', options: { // placeholder 占位符 name: '[name].[ext]', // 以相同的文件名和后缀进行打包 outputPath: 'images/' } } }, { // 用正则标识对哪些文件进行处理,正则对满足.scss结尾的文件执行下面的loader test: /\\.scss$/, use: [ 'style-loader', { loader: 'css-loader', options: { importLoaders: 2 } }, 'sass-loader', 'postcss-loader' ] // loader 的执行顺序是从下到上，从右到左 } ]}, 那么对于打包来说，究竟是什么样的流程呢？ npm run bundle // 或是npx webpack 执行这一命令 找到webpack.config.js配置项，根据配置项来进行打包，如果没有这个文件，会执行默认的参数进行打包 在打包的过程中，遇到js文件会直接进行打包，但是遇到其他类型的文件，如jpg文件，会查询配置文件，然后根据配置文件的参数，使用固定的loader进行打包 如遇到jpg，就会使用file-loader进行打包 那么file-loader究竟做什么了？ 发现了引入了图片 将图移动到指定的目录下 移动后，获取到新的文件的名字 将名称返回给引入模块的变量之中 其实url-loader和file-loader功能很相似，就是多了一个limit参数，我们可以设置这个参数，来决定什么时候用url-loader 样式的打包流程： 引入了一个css文件 需要先要安装 css-loader和style-loader 遇到css文件就会去使用css-loader和style-loader进行打包 把样式文档放在指定的文件中 css-loader：分析几个css文件之间的关系，并将几个css文件合并成一个css文件中style-loader：将css-loader合并的css文件挂载在指定文件的header上面 我们如果配饰了sass-loader或是less-loader的话，我们一般需要配置importLoaders：2,因为执行顺序是从下到上，从右到左，所以一点引入的less文件里面再次引入less文件会导致，打包可能不在走之前的sass-loader, postcss-loader,我们配置importLoaders：2就是为了规避这个问题","link":"/2020/11/01/webpack学习之loader/"},{"title":"webpack学习之plugins,entry,output","text":"我们先使用两个插件来看一下插件到底是什么？ html-webpack-plugin使用：这个插件运行时在打包结束的时候进行的 先在项目中安装插件，npm install html-webpack-plugin -D 在webpack.config.js中进行相关插件的配置 1234567891011121314151617const path = require('path'); // node 中的内置模块路径const HtmlWebpackPlugins = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = { mode: 'development', entry: './src/index.js', // 打包的入口文件 plugins: [ new HtmlWebpackPlugins({ template: 'src/index.html;' // 当打包的时候生成文件的时候，按照template配置的html进行生成 }), ], output: { filename: 'bindle.js', // 打包后输出的文件的名字 path: path.resolve(__dirname, 'dist') // 绝对路径,__dirname是webpack.config.js所在的路径的位置,输出的文件放在bundle的文件夹下 }}; html-webpack-plugin作用:会在打包结束后，自动生成一个html文件，并将打包生成的js自动引入到html中，当我们配置了template参数，会有一点区别，在打包生成html的时候，会根据指定的模板进行生成，并将打包生成的bindle.js注入到html文件中 ####clean-webpack-plugin 1234567891011121314151617const path = require('path'); // node 中的内置模块路径const HtmlWebpackPlugins = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = { mode: 'development', entry: './src/index.js', // 打包的入口文件 plugins: [ new HtmlWebpackPlugins({ template: 'src/index.html;' // 当打包的时候生成文件的时候，按照template配置的html进行生成 }), ], output: { filename: 'bindle.js', // 打包后输出的文件的名字 path: path.resolve(__dirname, 'dist') // 绝对路径,__dirname是webpack.config.js所在的路径的位置,输出的文件放在bundle的文件夹下 }}; 这个插件的作用就是在再次打包的时候dist文件夹中的内容清空 插件：在webpack运行到某个时刻的时候，帮我们做一些事情 Entry 和output基础1234567891011121314151617const path = require('path'); // node 中的内置模块路径const HtmlWebpackPlugins = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = { mode: 'development', entry: './src/index.js', // 打包的入口文件 plugins: [ new HtmlWebpackPlugins({ template: 'src/index.html;' // 当打包的时候生成文件的时候，按照template配置的html进行生成 }), ], output: { filename: 'bindle.js', // 打包后输出的文件的名字 path: path.resolve(__dirname, 'dist') // 绝对路径,__dirname是webpack.config.js所在的路径的位置,输出的文件放在bundle的文件夹下 }}; 这是最近简单的打包，打包成一个简单的文件，并引入到html中 当我们想有两个入口文件的时候12345678910111213141516171819202122const path = require('path'); // node 中的内置模块路径const HtmlWebpackPlugins = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = { mode: 'development', entry: { main: 'src/index.js', sub: 'src/index.js' }, plugins: [ new HtmlWebpackPlugins({ template: 'src/index.html;' }), new CleanWebpackPlugin(['dist ']) ], output: { filename: '[name].js', // 打包后输出的文件的名字，占位符 path: path.resolve(__dirname, 'dist') // 绝对路径,__dirname是webpack.config.js所在的路径的位置,输出的文件放在bundle的文件夹下 }}; 执行打包操作的时候，会将main.js和sub.js注入到html文件中 我们期望在注入html的时候，在js文件前添加一个地址12345output: { publicPath:'http://www.baidu.com', filename: '[name].js', // 打包后输出的文件的名字，占位符 path: path.resolve(__dirname, 'dist') // 绝对路径,__dirname是webpack.config.js所在的路径的位置,输出的文件放在bundle的文件夹下}","link":"/2020/11/01/webpack学习之plugins-entry-output/"},{"title":"webpack学习之sourceMap","text":"sourceMap在开发者模式下，默认source-map已经开启，如果我们想要关掉的话 1234module.exports ={ mode:'development', devtool:'none'} 如果我们期望以指定的方式开启，我们可以进行下面的配置： 1234module.exports ={ mode:'development', devtool:'source-map'} source-map:当有错误的时候，会生成一个映射关系，当我们没有开启source-map的时候，一旦代码出现问题，在控制台的错误提示，会提示我们打包后的js文件哪一行有错误，不利于我们进行错误的排查，我们开启source-map，source-map会为我们进行一次映射，体现在，我们在控制台查看错误的时候，会提示源代码中的哪一行有问题。source-map:会在打包的路径下，出现一个.map文件，用来记住映射inline-source-map:不会出现.map文件，这个映射直接以base64的形式记录到打包的目标文件中cheap-inline-source-map:当项目很大，有cheap这个前缀就会大大的优化性能，对于保存，只会提示到行，不会再精确到列了，而且，按照这样的方式进行映射，只会针对自己的逻辑代码，不会再考虑第三方的模块。cheap-module-inline-source-map：不仅仅针对自己的逻辑代码，还会考虑第三方的模块eval:针对大型项目，可能提示信息不会很全 最佳时间开发环境 1234module.exports ={ mode:'development', devtool:'cheap-module-eval-source-map'} 生产环境 1234module.exports ={ mode:'production', devtool:'cheap-module-source-map'}","link":"/2020/11/01/webpack学习之sourceMap/"},{"title":"webpack学习之基础概念","text":"webpack出现的背景1.当项目中引入多个js文件的时候，页面加载的速度就会慢很多，因为多了http的请求2.面向对象的编程方式的出现3.如果按照传统的方式进行文件的引入，就会失去文件和文件之间的位置关系综上所述：webpack是一个模块打包工具利用webpack进行打包，引入模块的方式，我们一般用的有两种 ES module 模块的引入方式，分别使用关键字import和export （import使用的前提是先export） commonJS的模块引入方式const header = require ('./header.js')；导入module.exports = Header; 导出 webpack的环境 —&gt; 给予node的打包工具 安装npm,在官网上直接进行安装 在左面创建一个webpack的文件夹，并进入文件夹 3.执行npm init 以node规范的形式创建一个项目 4.修改package.json 5.安装webpack、webpack-cli (不推荐全局的安装webpack) 全局安装npm install webpack webpack-cli -g // 安装npm uninstall webpack webpack-cli -g // 卸载 项目级安装npm install webpack webpack-cli --save-dev// 安装npx webpack -v // 对版本进行打印 现在我们看一下我们配置好的package.json 123456789101112{ \"name\": \"webpack-demo\", \"version\": \"1.0.0\", \"description\": \"\", \"private\": true, \"author\": \"kim\", \"license\": \"ISC\", \"devDependencies\": { \"webpack\": \"^4.41.2\", \"webpack-cli\": \"^3.3.9\" }} webpack配置文件进行配置 我们想要对项目进行配置，我们先要编写一个配置文档，这个文档我们一般取名为 webpack.config.js 如果我们不想取名为上面的名字，如我们的配置文档叫做 webpack.js，那我们在执行打包的时候们就要指定一下配置文档的名字 npx webpack --config webpack.js 如果我们想要使用npm script进行执行代码的简化，那么我们需要在package.json进行配置script参数 webpack-cli 我们安装这个是为了让我们在命令行中可以正确的运行webpack命令 json文件的配置script 123456789101112131415{ \"name\": \"webpack-demo\", \"version\": \"1.0.0\", \"description\": \"\", \"private\": true, \"scripts\": { \"bundle\": \"webpack\" }, \"author\": \"kim\", \"license\": \"ISC\", \"devDependencies\": { \"webpack\": \"^4.41.2\", \"webpack-cli\": \"^3.3.9\" }} 12345678910const path = require('path'); // node 中的内置模块路径module.exports = { mode: 'development', entry: './src/index.js', // 打包的入口文件 output: { filename: 'bindle.js', // 打包后输出的文件的名字 path: path.resolve(__dirname, 'dist') // 绝对路径,__dirname是webpack.config.js所在的路径的位置,输出的文件放在bundle的文件夹下 }};","link":"/2020/11/01/webpack学习之基础概念/"},{"title":"作用域","text":"了解JavaScript的机制我们学习作用域的方法是将这个过程模拟成几个人之间的对话，那么我们先看一下都有谁参与到了这个对话： 演员表引擎：从头到尾负责整个JavaScript的编译和执行的过程编译器：引擎的好朋友之一，主要的工作是语法的分析和代码的生成作用域：引擎的另外一位好朋友，负责收集并且维护所有声明的标识符进而组成一系列的查询，并执行一非常严格的规则，确定当前执行的代码的这些标识符的访问权限。 对话当我们看到var a = 2；这段程序的时候，很可能认为这是一句声明的语句。但是在引擎的眼中，这个是两个过程：一个由编译器在编译的时候处理，另外的一个是引擎在执行的时候处理。我们仔细的看一下这段代码在底层究竟是如何实现的： 遇到var a；这个语句的时候，会询问作用域是否已经有一个该名字的变量存在在同一个作用域中，如果有的话，就会忽略这个声明，否则，他会要求作用域在当前作用域的集合中声明一个新的变量。 接下来编译器会为引擎生成运行时需要的代码，这些代码用来处理a = 2这个赋值操作，引擎运行时先访问作用域，在当前的作用中是否有一个叫做a的变量，如果有，引擎就会使用这个变量，如果没有，引擎就会继续查找这个变量，如果找到这个变量，就会将2赋值给他，如果没有找到的话，就会抛出一个异常。函数作用域在任意的代码片段外添加包装函数，可以将内部的变量和函数定义隐藏起来，导致外部是没有办法访问内部的任何内容的。1234567var a = 2;foo = ()=&gt;{ // &lt;--添加了这一行 var a = 3; console.log(a); //3}// &lt;--添加了这一行foo();// &lt;--添加了这一行console.log(a) // 2 这个技术解决了一写问题，但是还是有一点不理想，因为会导致一些其他的问题，因为这么做应该先声明一个具名函数foo(),但是这个foo()污染了全局作用域，其次，还是需要显示的调用才可以，但是我们期望可以不用使用函数名，并且可以自行运行，这样就更加理想了。 1234567var a = 2;(()=&gt;{ // &lt;--添加了这一行 var a = 3; console.log(a); // 3})() // &lt;--添加了这一行console.log(a) // 2 匿名和具名对于函数表达式最熟悉的场景就是毁掉参数，举个例子： 123setTimeout(()=&gt;{ console.log(\"I waited 1 second\")}) 上面的就是匿名函数表达式，因为function()..没有名称标识符，函数表达式是可以匿名的，然而函数表达式是不可以忽略函数名的– 在JavaScript中是违法的。匿名函数的缺点： 匿名韩式在栈追踪中不会显示出有具体意义的函数名，让调试变得很有困难。 没有函数名，当函数需要引用自身的时候只能使用已经过期的arguments.callee引用，比如：在递归中，另一个行数需要引用自身的例子，在时间触发之后时间监听器需要解绑自身。 匿名函数省略了对于代码可读性/可理解性很重要的函数名，一个描述性的名称可以让代码不言而喻。 立即执行函数表达式1234567var a = 2;(foo =()=&gt;{ var a = 3; console.log(a); // 3})();console.log(a); // 2 上面的函数被包含在一个括号的内部，因此形成了一个表达式，然后在结尾还添加了一个(),可以来立即执行这个函数，比如(foo=()={..})()立即执行函数表达式的进阶使用方法：就是你把他们当做函数调用并传递参数进去。 12345678var a = 2;(function foo(global){ var a = 3; console.log(a); // 3 console.log(global.a); // 2})(window);console.log(a); // 2 我们将window对象的引用传递进去，并将其命名为global，因此在代码风格上对全局对象的引用变得比引用一个没有全局字样的变量更加清楚啦。这个模式的另外的一个应用场景就是解决undefined标识符的默认值被错误覆盖导致异常的情况。比如说：我们将一个参数命名成undefined，但是在对应的位置不传入任何的值，这样就可以保证在代码块中的undefined标识符的值就是undefined。 1234567undefined = true; // 这样做对其他的代码是不好的，一定不要这么做(foo= (undefined)=&gt;{ var a ; if(a ===undefined){ console.log('undefined is safe here'); }})(); 任何的声明在某个作用域内的变量，都将依附于这个作用域。 12345678a = 2;var a;console.log(a); // 2// ===&gt; 等价于var a; // 进行编译a = 2; // 执行的时候进行赋值console.log(a) 12console.log(a); // undefinedvar a = 2; 导致上面的结果很简单，声明本身会被提升，提升到最开始，然而赋值或是其他的运行逻辑，会被留在原地。注意一下，我们在进行状态提升的时候会先提升函数的状态，其次才是函数的状态。 12345678foo(); // 1var foo;function foo(){ console.log(1);} foo = function(){ console.log(2)} 因为对于上面的代码，JavaScript的引擎是这样进行理解的： 1234567function foo(){ console.log(1);}foo(); foo = function(){ console.log(2)}","link":"/2020/11/01/作用域/"},{"title":"修Bug注意事项","text":"1.将变量名和函数名取成了相同的名字：有的时候，我们会不注意的时候，将变量的名字和函数的名字取成相同的名字，这样的话，会造成值的覆盖问题，导致bug出现。 2.对于if-else的使用我们条件分支里面写代码的时候，一定要注意，自己所写的代码是针对于上面条件的，尤其是if-else if-else if-else 最后的一个else中可能包含多个条件，在这个else中写代码的时候，是否这里的状况都符合要求。3.对异常的处理当我们直接拿到一个字符串就进行操作，而不考虑这个字符串的具体情况，就会出现问题，比如说：str 是之前得到的一个字符串，直接对其进行操作，str.split（'-'），这个时候如果str为空或是undefined就会进行报错。在下面进行代码说明： 12345678let test (language)=&gt;{ let str = ''; str = language ; str.split('-'); //这个时候可能会报错，解决的方法如下 if(str !== undefined &amp;&amp;str !== null &amp;&amp; str !== ''){ str.split('-'); }} 4.对于给动态添加的dom节点进行修改操作我们对于动态添加的节点再一次进行操作，要确定之前动态操作是已经生效的，否则后续的操作是可能无法生效。","link":"/2020/11/01/修Bug注意事项/"},{"title":"修改git的密码导致git上传失败","text":"我们有的时候修改了git的密码，然后发现我们在向远程仓库上传代码，发现上传代码失效了，这个时候我们可以进行如下的操作：","link":"/2020/11/01/修改git的密码导致git上传失败/"},{"title":"修改本地的git的远程提交地址","text":"前提当需要对于代码进行不同的git库的迁移，我们需要将本地的代码远程仓库进行修改 操作步骤 如果没有这个目录，将隐藏的文件显示出来 找到git 目录下的config的文件： 将相对应的文件地址进行依次的修改","link":"/2020/11/01/修改本地的git的远程提交地址/"},{"title":"Async/Await简介与用法","text":"在日常工作中遇到的一些公关方法的封装 获取字符串长度（英文占一个字符，中文两个字符）使用方法，传入一个字符串，返回这个字符串的长度，其中英文占一个字符，中文两个字符。 12345678910111213141516const bytesCount = str =&gt;{ if(str !== null &amp;&amp; str !== undefined){ let bCount = 0; for(let i = 0; i&lt;str.length;i++){ const c = str.charAt(i); const flag = /^[\\u0020-\\uooff]$/.test(c); if(flag){ bCount+ =1; }else{ bCount+ =2; } } return bCount; }}; 单位转换（将B转换成合适的单位 如KB、MB…） 进行单位转换，其中用到了lodash中的findIndex()方法 123456789101112131415161718/* * @param{*} bytes 传入具体的值，也就是将要进行转换的值* @param{*} number 传入具体的值的单位* 返回一个结果数组[6,'M'] 返回一个数组，第一位是值，第二位是单位*/import {findIndex} from 'lodash';const tranformBytes =(bytes,{minUnit = 'B'}={})=&gt;{ const units =['B','KB','MB','GB','TB','PB']; // 单位的合集 const minUnitIndex = findIndex(units,value=&gt;value=== minUnit); // 最小的显示单位 let index; // 下标 用来计算合适单位的下标 for(index = minUnitIndex ;index &lt;= units.length;index++){ if(index === units.length || bytes &lt; Math.pow(1024,index+1) ){ break; } } return [bytes / Math.pow(1024,index+1),units[index]];}","link":"/2020/11/01/前端公共方法/"},{"title":"前端面试题","text":"BFC的认知(块级格式化上下文)了解BFC这个概念吗？ BFC：块级格式化上下文，它是指一个独立的块级渲染区域，只有Block-level 盒子参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。 BFC 的生成条件 为根元素 float的值不为none overflow值不为visible display的值为inline-block、table-cell、table-caption position的值为fixed、absolute BFC的应用：放置margin的重叠 在同一个BFC中，两个相邻的Box才会发生重叠与方向没有关系，我们很少可以看到在水平方向的margin的重叠，但是在IE浏览器中，可以设置write-mode来实现水平方向的布局。 123456789101112131415161718192021#green{ margin:10px 10px 10px 10px; background:lightgreen; height:100px; width:100px;}#blue{ margin:10px 10px 10px 10px; background:lightblue; height:100px; width:100px;}#red{ margin:10px 10px 10px 10px; background:pink; height:100px; width:100px;} body { writing-mode:tb-rl; } 12345&lt;body&gt; &lt;div id=&quot;green&quot;&gt;&lt;/div&gt; &lt;div id=&quot;blue&quot;&gt;&lt;/div&gt; &lt;div id=&quot;red&quot;&gt;&lt;/div&gt;&lt;/body&gt; 现在两个盒子之间的margin值是10px而不是我们想象中的20px。 HTTP的状态码简单描述以下HTTP的状态码的意思？ 1XX 信息提示2XX 成功3XX 重定向4XX 客户端错误5XX 服务器错误 常用的状态码：301/302 Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置304 Not Modified（未修改）客户的缓存资源是最新的， 要客户端使用缓存202 Accepted（已接受） 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 GET和Post的区别 GET在浏览器回退时是无害的，而POST会再次提交请求 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 GET参数通过URL传递，POST放在Request body中 es6相对于es5 ，es6新增的特性有哪些？ ES6新特性：let/const，解构赋值，模板字符串，箭头函数，默认参数，类，模块化，…展开运算符，Symbol，Promise，async/await，Map/Set，Array.includes()，指数操作符等 那对于Promise你能说出一些经常使用的方法吗？ catch、then、race、all 请写出代码的输出结果 123456789101112131415161718192021222324252627282930313233343536runAsync1 = () =&gt;{ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log(&apos;异步任务1执行完成&apos;); resolve(&apos;随便什么数据1&apos;); }, 1000); }); return p; }runAsync2 = () =&gt;{ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log(&apos;异步任务2执行完成&apos;); resolve(&apos;随便什么数据2&apos;); }, 2000); }); return p; }runAsync3 = () =&gt;{ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log(&apos;异步任务3执行完成&apos;); resolve(&apos;随便什么数据3&apos;); }, 2000); }); return p; }Promise.all([runAsync1(), runAsync2(), runAsync3()]).then(function(results){ console.log(results);}); 123456789101112131415161718192021222324252627282930313233343536runAsync1 = () =&gt;{ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log(&apos;异步任务1执行完成&apos;); resolve(&apos;随便什么数据1&apos;); }, 1000); }); return p; }runAsync2 = () =&gt;{ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log(&apos;异步任务2执行完成&apos;); resolve(&apos;随便什么数据2&apos;); }, 2000); }); return p; }runAsync3 = () =&gt;{ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log(&apos;异步任务3执行完成&apos;); resolve(&apos;随便什么数据3&apos;); }, 2000); }); return p; }Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results){ console.log(results);}); ps:promise一旦执行，过程是不可逆的，不能停止 深拷贝和浅拷贝的区别是什么浅拷贝:只复制第一层得到的新实例：对于基本数据类型，会在堆中重新开辟一块内存，修改后不会相互影响，对于引用数据类型，因为只拷贝了一层，所以指针还是指向同一块堆内存，会相互影响深拷贝:递归复制了所有层级得到的新实例：无论是基本数据类型还是引用数据类型，内存上都会重新创建，两个对象不会相互影响 浅拷贝的实现方法： 对于数组来说： Array.prototype.slice() Array.prototype.concat() Array.from(obj) Object.assign([], obj) […obj] jQuery.extend([], obj) lodash.clone(obj) 对象浅拷贝 Object.assign({}, obj) {…obj}，jQuery.extend({}, obj) lodash.clone(obj) 深拷贝的实现方法： JSON.parse(JSON.stringify(obj)) 可以问一下什么情况不能使用JSON方法 jQuery.extend(true, [], obj) lodash.cloneDeep(obj) webpack说一下自己知道的loader和plugin 常用loader file-loader url-loader style-loader css-loader， less-loader sass-loader postcss-loader babel-loader 常用plugin HtmlWebpackPlugin CleanWebpackPlugin HotModuleReplacementPlugin DefinePlugin MiniCssExtractPlugin 浏览器兼容问题ReactReact的纯函数组件的特性 组件不会被实例化，整体渲染性能得到提升 组件不能访问this对象 组件无法访问生命周期的方法 无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用","link":"/2020/11/01/前端面试题/"},{"title":"对大屏项目的基本配置（rem）","text":"如果我们想要做一个非标准屏幕的大屏，西药进行一定的配置 如果我们想要实现一个基于react的大屏的项目，我们采用的是rem的框架，下面看看我们的如何进行配置的。第一步,安装react的脚手架： 首先基于npm在全局安装create-react-app:npm install -g create-react-app 在指定目录中创建一个react项目工程:create-react-app my-app 第二步：将webpack从nodemodel里面抛出 yarn eject 第三步：安装一些必要的依赖包，我安装了moment，echarts，echarts-for-react，lodash ，less，less-loader yarn add moment echarts echarts-for-react lodash less less-loader对webpack进行相对应的配置我用的是最近的react的create-react-app的脚手架，版本是3.0.0，在webpack.config.js里面进行配置less的相关 如果有错误的话，这个地方是针对于antdesign来进行配置的，不配置可能会报错，但是由于我后来的大屏的方案与antdesign是不兼容的，就没有使用antdesign，但是这个配置依旧保留了下来。 第四步：安装大屏的插件，也就是将px转换成rem的插件： 对大屏的插件进行配置 上面的插件的npm地址这片技术方案是参照这片文章来实现的","link":"/2020/11/01/前端大屏的基本配置/"},{"title":"动态向表头添加列的表格-基于antdesign","text":"git地址的compont文件夹中 使用参数的参数列表： 下拉框实现的效果和antdesign自己声明的过滤器效果一样，但是由于我们的操作逻辑和过滤的逻辑不尽相同，所以自己封装了点击下拉的那个部分。 表格源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208/** * * dataSource用来传入表格中想要显示的数据 * headerSetting用来传入初始表头的选项内容 eg：[{ title: '序号', dataIndex: 'order', key: 'num' }] * choice用来传入点击图标后，出现的复选框的内容 eg：[{ title: 'Male0', key: 'male0', dataIndex: 'male0' }] * onInquireItem={this.onInquireItem} 对应操作中的查询按钮 * onCloseItem={this.onInquireItem} 对应操作中的关闭按钮 * onDeleteItem={this.onInquireItem} 对应操作中的删除按钮 */import React, { Component } from 'react';import { Icon, Table, Checkbox } from 'antd';import { findIndex } from 'lodash';import iconFont from 'Assets/iconfont.js';import PropTypes from 'prop-types';import './style.less';const { Column } = Table;const IconFont = Icon.createFromIconfontCN({ script: iconFont})class HeaderSettingTable extends Component { state = { tableHeader: [], tableHeaderOlder: [], additionChoice: [], showChoice: false, checkState: [] } // 绑定鼠标的点击事件 componentWillUnmount() { window.removeEventListener('mouseup', this.handleMouseUp) } // 当页面挂载的时候，将需要的数据进行整理 componentDidMount() { let olderHeader = []; for (let i = 0; i &lt; this.props.choice.length; i++) { this.state.checkState.push(false) } olderHeader = JSON.parse(JSON.stringify(this.props.headerSetting)); window.addEventListener('mouseup', this.handleMouseUp) this.setState({ tableHeader: this.props.headerSetting, tableHeaderOlder: olderHeader }); } //将不必要的数据置空 resetCheckBox = (arr, flag) =&gt; { let num = 0; for (let i = 0; i &lt; arr.length; i++) { if (arr[i] === true) { num++ } } if (flag &amp;&amp; num !== this.state.additionChoice.length) { for (let i = 0; i &lt; this.props.choice.length; i++) { let result = findIndex(this.state.additionChoice, this.props.choice[i]); if (result === -1) { arr[i] = false; } else { arr[i] = true; } } this.setState({ checkState: arr }) } } //点击页面空白区域,更多弹层消失 handleMouseUp = (newData) =&gt; { let arr = JSON.parse(JSON.stringify(this.state.checkState)); if (this.state.additionChoice.length === 0) { for (let i = 0; i &lt; this.state.additionChoice.length; i++) { arr[i] = false; this.setState({ checkChoice: arr }) } } document.onmouseup = (event) =&gt; { let flag = event.target.id !== 'choiceModal' &amp;&amp; event.target.parentElement.id !== 'iconId' &amp;&amp; (event.target.parentElement.parentElement.parentNode.id || event.target.parentElement.parentElement.id) !== 'choiceModal' this.resetCheckBox(newData, flag); if (event.target.id !== 'choiceModal' &amp;&amp; event.target.parentElement.id !== 'iconId') { this.setState({ showChoice: false }) } } } // 点击多选框的时候，对多选框中的值进行查看 checkChoice = (index, event) =&gt; { let newData = JSON.parse(JSON.stringify(this.state.checkState)); newData[index] = !newData[index]; this.setState({ showChoice: true, checkState: newData }); let value = JSON.parse(JSON.stringify(newData)) this.handleMouseUp(value) } // 点击确认按钮的时候，将选中列加入到表格的表头中去 confirmClick = () =&gt; { this.setState({ tableHeader: this.state.tableHeaderOlder, }); for (let i = 0; i &lt; this.state.checkState.length; i++) { let index = findIndex(this.state.additionChoice, this.props.choice[i]); if (this.state.checkState[i]) { if (index === -1) { this.state.additionChoice.push(this.props.choice[i]); } } else { if (index !== -1) { this.state.additionChoice.splice(index, 1); } } } let tempArr = JSON.parse(JSON.stringify(this.state.tableHeaderOlder)); for (let i = this.state.additionChoice.length - 1; i &gt; -1; i--) { let objectItem = this.state.additionChoice[i] tempArr.splice(2, 0, objectItem); this.setState({ tableHeader: tempArr }); } } // 点击取消按钮 clearClick = () =&gt; { let clearArr = []; for (let i = 0; i &lt; this.props.choice.length; i++) { clearArr[i] = false; } let tempArr = JSON.parse(JSON.stringify(this.state.tableHeaderOlder)); this.setState({ tableHeader: tempArr, checkState: clearArr, additionChoice: [] }); } // 点击图标的 clickIcon = (event) =&gt; { this.setState({ showChoice: !this.state.showChoice }) } operateCell = (text, recorder) =&gt; { return ( &lt;div&gt; &lt;a onClick={() =&gt; this.props.onInquireItem(recorder)}&gt;查询&lt;/a&gt; &lt;a className='a-Style' onClick={() =&gt; this.props.onCloseItem(recorder)}&gt;关闭&lt;/a&gt; &lt;a className='a-Style' onClick={() =&gt; this.props.onDeleteItem(recorder)}&gt;删除&lt;/a&gt; &lt;/div&gt; ) } // 下拉框的样式的编写 titleHandle = () =&gt; { return ( &lt;div&gt; &lt;span&gt;操作&lt;/span&gt; &lt;IconFont id='iconId' type=\"icon-empty-setting\" className='Icon-style' onClick={() =&gt; this.clickIcon(event)} /&gt; &lt;div id='choiceModal' className={this.state.showChoice ? 'ant-table-filter-dropdown item-style show-item' : 'ant-table-filter-dropdown item-style hidden-item'} &gt; {this.props.choice.map((item, index) =&gt; { return (&lt;Checkbox onChange={this.checkChoice.bind(this, index)} className='checkBox-style' key={item.title} checked={this.state.checkState[index]}&gt;{item.key}&lt;/Checkbox&gt;) })} &lt;div className='ant-table-filter-dropdown-btns line-top'&gt; &lt;a className='ant-table-filter-dropdown-link confirm' onClick={() =&gt; this.confirmClick()} &gt;确定&lt;/a&gt; &lt;a className='ant-table-filter-dropdown-link clear' onClick={() =&gt; this.clearClick()} &gt;重置&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div &gt; ) } render() { return ( &lt;div&gt; &lt;Table dataSource={this.props.dataSource} scroll={{ x: this.state.tableHeader.length * 150 + 200 }} &gt; &lt;Column key='normalNum' title='序号' width={80} fixed={'left'} render={(text, recorder, index) =&gt; &lt;span&gt;{index + 1}&lt;/span&gt;} /&gt; { this.state.tableHeader.map((item) =&gt; { return (&lt;Column key={item.key} className={'Column-width'} title={item.title} dataIndex={item.dataIndex} /&gt;) }) } &lt;Column key='ok' title={this.titleHandle()} width={136} fixed={'right'} render={(text, recorder) =&gt; this.operateCell(text, recorder)} /&gt; &lt;/Table&gt; &lt;/div &gt; ) }}HeaderSettingTable.propTypes = { headerSetting: PropTypes.array, onInquireItem: PropTypes.func, onCloseItem: PropTypes.func, onDeleteItem: PropTypes.func, choice: PropTypes.array, dataSource: PropTypes.array}export default HeaderSettingTable;","link":"/2020/11/01/动态向表头添加列的表格-基于antdesign/"},{"title":"多分支git的开发","text":"我们在进行代码管理的时候，经常要使用git，理论上会有一个master主分支，以及release的测试分支（用于版本的发布），develop的研发自己进行分开发的分支。我们一般的流程是在develop上进行开发，然后到要发版本的时候，将develop的分支合并到release分支上面，然后在release测试完成，完全没有问题的时候，会将release分支的代码合并到master的分支上面，将master分支的代码作为发版的代码发布出去。现在简单写几个我们需要用到的命令。 git checkout -b develope origin/develop 将代码以不融合的方式拉取下来，并且直接切换到develop的分支上面git status 检查在这个分支上面都有哪些代码进行修改了git add . 将修改的文件提到本地的暂存区git commit -m 'kim:【other】xxx' 实际上就是把暂存区的内容提交到了到了当前的分支 -m的意思是添加注释，后面是注释的内容git pull origin develop 将远程的develop分支上的东西拉取下来并和本地的代码进行融合git push origin develop 将本地的分支上面的东西推送到了远程仓库中 git stash 对本地的一些不想提交的东西开辟了一写空间进行展示性的存储，这样方便我们切换到别的分支上进行工作 git stash list 可以看一下我们stash的情况 如果我们想要使用暂存区中的东西 ，我们可以使用git stash apply。举个栗子：git stash apply stash@{2}你也可以运行 git stash pop 来重新应用储藏，同时立刻将其从堆栈中移走。","link":"/2020/11/01/多分支git的开发/"},{"title":"在echarts使用地图的坐标","text":"现在的echarts下线了地图的一些功能，导致有的时候我们画世界地图的时候，找不到具体的坐标，在这里我提供了一些坐标，如果坐标的值不够的话，可以根据下面的方法进行添加： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183let geoCoordMap = { 阿富汗: [67.709953, 33.93911], 安哥拉: [17.873887, -11.202692], 阿尔巴尼亚: [20.168331, 41.153332], 阿联酋: [53.847818, 23.424076], 阿根廷: [-63.61667199999999, -38.416097], 亚美尼亚: [45.038189, 40.069099], 法属南半球和南极领地: [69.348557, -49.280366], 澳大利亚: [133.775136, -25.274398], 奥地利: [14.550072, 47.516231], 阿塞拜疆: [47.576927, 40.143105], 布隆迪: [29.918886, -3.373056], 比利时: [4.469936, 50.503887], 贝宁: [2.315834, 9.30769], 布基纳法索: [-1.561593, 12.238333], 孟加拉国: [90.356331, 23.684994], 保加利亚: [25.48583, 42.733883], 巴哈马: [-77.39627999999999, 25.03428], 波斯尼亚和黑塞哥维那: [17.679076, 43.915886], 白俄罗斯: [27.953389, 53.709807], 伯利兹: [-88.49765, 17.189877], 百慕大: [-64.7505, 32.3078], 玻利维亚: [-63.58865299999999, -16.290154], 巴西: [-51.92528, -14.235004], 文莱: [114.727669, 4.535277], 不丹: [90.433601, 27.514162], 博茨瓦纳: [24.684866, -22.328474], 中非共和国: [20.939444, 6.611110999999999], 加拿大: [-106.346771, 56.130366], 瑞士: [8.227511999999999, 46.818188], 智利: [-71.542969, -35.675147], 中国: [104.195397, 35.86166], 象牙海岸: [-5.547079999999999, 7.539988999999999], 喀麦隆: [12.354722, 7.369721999999999], 刚果民主共和国: [21.758664, -4.038333], 刚果共和国: [15.827659, -0.228021], 哥伦比亚: [-74.297333, 4.570868], 哥斯达黎加: [-83.753428, 9.748916999999999], 古巴: [-77.781167, 21.521757], 北塞浦路斯: [33.429859, 35.126413], 塞浦路斯: [33.429859, 35.126413], 捷克共和国: [15.472962, 49.81749199999999], 德国: [10.451526, 51.165691], 吉布提: [42.590275, 11.825138], 丹麦: [9.501785, 56.26392], 多明尼加共和国: [-70.162651, 18.735693], 阿尔及利亚: [1.659626, 28.033886], 厄瓜多尔: [-78.18340599999999, -1.831239], 埃及: [30.802498, 26.820553], 厄立特里亚: [39.782334, 15.179384], 西班牙: [-3.74922, 40.46366700000001], 爱沙尼亚: [25.013607, 58.595272], 埃塞俄比亚: [40.489673, 9.145000000000001], 芬兰: [25.748151, 61.92410999999999], 斐: [178.065032, -17.713371], 福克兰群岛: [-59.523613, -51.796253], 法国: [2.213749, 46.227638], 加蓬: [11.609444, -0.803689], 英国: [-3.435973, 55.378051], 格鲁吉亚: [-82.9000751, 32.1656221], 加纳: [-1.023194, 7.946527], 几内亚: [-9.696645, 9.945587], 冈比亚: [-15.310139, 13.443182], 几内亚比绍: [-15.180413, 11.803749], 赤道几内亚: [10.267895, 1.650801], 希腊: [21.824312, 39.074208], 格陵兰: [-42.604303, 71.706936], 危地马拉: [-90.23075899999999, 15.783471], 法属圭亚那: [-53.125782, 3.933889], 圭亚那: [-58.93018, 4.860416], 洪都拉斯: [-86.241905, 15.199999], 克罗地亚: [15.2, 45.1], 海地: [-72.285215, 18.971187], 匈牙利: [19.503304, 47.162494], 印尼: [113.921327, -0.789275], 印度: [78.96288, 20.593684], 爱尔兰: [-8.24389, 53.41291], 伊朗: [53.688046, 32.427908], 伊拉克: [43.679291, 33.223191], 冰岛: [-19.020835, 64.963051], 以色列: [34.851612, 31.046051], 意大利: [12.56738, 41.87194], 牙买加: [-77.297508, 18.109581], 约旦: [36.238414, 30.585164], 日本: [138.252924, 36.204824], 哈萨克斯坦: [66.923684, 48.019573], 肯尼亚: [37.906193, -0.023559], 吉尔吉斯斯坦: [74.766098, 41.20438], 柬埔寨: [104.990963, 12.565679], 韩国: [127.766922, 35.907757], 科索沃: [20.902977, 42.6026359], 科威特: [47.481766, 29.31166], 老挝: [102.495496, 19.85627], 黎巴嫩: [35.862285, 33.854721], 利比里亚: [-9.429499000000002, 6.428055], 利比亚: [17.228331, 26.3351], 斯里兰卡: [80.77179699999999, 7.873053999999999], 莱索托: [28.233608, -29.609988], 立陶宛: [23.881275, 55.169438], 卢森堡: [6.129582999999999, 49.815273], 拉脱维亚: [24.603189, 56.879635], 摩洛哥: [-7.092619999999999, 31.791702], 摩尔多瓦: [28.369885, 47.411631], 马达加斯加: [46.869107, -18.766947], 墨西哥: [-102.552784, 23.634501], 马其顿: [21.745275, 41.608635], 马里: [-3.996166, 17.570692], 缅甸: [95.956223, 21.913965], 黑山: [19.37439, 42.708678], 蒙古: [103.846656, 46.862496], 莫桑比克: [35.529562, -18.665695], 毛里塔尼亚: [-10.940835, 21.00789], 马拉维: [34.301525, -13.254308], 马来西亚: [101.975766, 4.210484], 纳米比亚: [18.49041, -22.95764], 新喀里多尼亚: [165.618042, -20.904305], 尼日尔: [8.081666, 17.607789], 尼日利亚: [8.675277, 9.081999], 尼加拉瓜: [-85.207229, 12.865416], 荷兰: [5.291265999999999, 52.132633], 挪威: [8.468945999999999, 60.47202399999999], 尼泊尔: [84.12400799999999, 28.394857], 新西兰: [174.885971, -40.900557], 阿曼: [55.923255, 21.512583], 巴基斯坦: [69.34511599999999, 30.375321], 巴拿马: [-80.782127, 8.537981], 秘鲁: [-75.015152, -9.189967], 菲律宾: [121.774017, 12.879721], 巴布亚新几内亚: [143.95555, -6.314992999999999], 波兰: [19.145136, 51.919438], 波多黎各: [-66.590149, 18.220833], 北朝鲜: [127.510093, 40.339852], 葡萄牙: [-8.224454, 39.39987199999999], 巴拉圭: [-58.443832, -23.442503], 卡塔尔: [51.183884, 25.354826], 罗马尼亚: [24.96676, 45.943161], 俄罗斯: [105.318756, 61.52401], 卢旺达: [29.873888, -1.940278], 西撒哈拉: [-12.885834, 24.215527], 沙特阿拉伯: [45.079162, 23.885942], 苏丹: [30.217636, 12.862807], 南苏丹: [31.3069788, 6.876991899999999], 塞内加尔: [-14.452362, 14.497401], 所罗门群岛: [160.156194, -9.64571], 塞拉利昂: [-11.779889, 8.460555], 萨尔瓦多: [-88.89653, 13.794185], 索马里兰: [46.8252838, 9.411743399999999], 索马里: [46.199616, 5.152149], 塞尔维亚共和国: [21.005859, 44.016521], 苏里南: [-56.027783, 3.919305], 斯洛伐克: [19.699024, 48.669026], 斯洛文尼亚: [14.995463, 46.151241], 瑞典: [18.643501, 60.12816100000001], 斯威士兰: [31.465866, -26.522503], 叙利亚: [38.996815, 34.80207499999999], 乍得: [18.732207, 15.454166], 多哥: [0.824782, 8.619543], 泰国: [100.992541, 15.870032], 塔吉克斯坦: [71.276093, 38.861034], 土库曼斯坦: [59.556278, 38.969719], 东帝汶: [125.727539, -8.874217], 特里尼达和多巴哥: [-61.222503, 10.691803], 突尼斯: [9.537499, 33.886917], 土耳其: [35.243322, 38.963745], 坦桑尼亚联合共和国: [34.888822, -6.369028], 乌干达: [32.290275, 1.373333], 乌克兰: [31.16558, 48.379433], 乌拉圭: [-55.765835, -32.522779], 美国: [-95.712891, 37.09024], 乌兹别克斯坦: [64.585262, 41.377491], 委内瑞拉: [-66.58973, 6.42375], 越南: [108.277199, 14.058324], 瓦努阿图: [166.959158, -15.376706], 西岸: [35.3027226, 31.9465703], 也门: [48.516388, 15.552727], 南非: [22.937506, -30.559482], 赞比亚: [27.849332, -13.133897], 津巴布韦: [29.154857, -19.015438], 澳门: [113.5, 22.2], 新加坡: [103.811032, 1.364418], 印度尼西亚: [119.730443, -5.640499], \"刚果（金）\": [21.23189, -3.79294]}; 但是有的时候我们想要使用的地方还是不够，我们需要在添加一些地图的坐标：我们添加的方法如下： 访问百度地图的网址 拉到页面的最下面，选择坐标拾取。 3.进入到如下的页面 找到地点 然后进行定点，复制当前坐标的值：","link":"/2020/11/01/在echarts使用地图的坐标/"},{"title":"学习的目录","text":"重学前端 你不知道的JavaScript 路由 https://juejin.im/post/5995a2506fb9a0249975a1a4 TypeScrip hook redux echarts（源码） https://github.com/webbillion/xrender-notes webpack （官方文档） https://github.com/BiosBoy/coconat(看过之后的时间) https://blog.usejournal.com/lets-kill-create-react-app-452cb55f77d3?gi=e1305e8aa9a9 babel node python docker 数据库基础 单元测试 React Fiber架构","link":"/2020/11/01/学习的目录/"},{"title":"强制类型转换","text":"在JavaScript的世界里面，有两种类型转换，分别是：隐式强制类型转换和显示强制类型转化来区分。 ToString基本类型的转化规则为： null 转换成 “null” undefined 转换成 “undefined” true 转换成 “true” 数字的字符串遵循通用的规则 对于数字而言存在指数的形式，转换的时候会自动的转换成科学计数法,在进行处理的时候需要注意一下 123var a = 1.07*1000*1000*1000*1000*1000*1000*1000;a.toString(); // \"1.07e21\" 对于数组的tiString()方法进行了重新的定义，吧所有单元串化后，再使用”,”进行连接 12var a = [1,2,3];a.toString(); // 1,2,3 JSON字符串化工具函数JSON.stringify(..)在将JSON对象序列化为字符串的时候也是使用了ToString。 下面这个场景的字符串转换我们应该特意的注意一下： 1JSON.stringify(\"42\") // \"\"42\"\"(含有引号的字符串) JSON.stringify(..)在对象中遇到undefined、function、symbol会自动将其忽略，在数组中则会返回null，目的是保证单元的位置是不变的。 1234JSON.stringify(undefined); // undefinedJSON.stringify(function(){});// undefinedJSON.stringify([1,undefined,function(){},4]); // '[1,null,null,4]'JSON.stringify({a:2,b:function(){}}); // \"{\"a\":2}\" 对于包含循环引用的对象，执行上述的操作会直接进行报错。 ToNumber基本的转换类型： true 转换成 1 false 转换成 0 undefined 转换成NaN null 转换成 0 我们进行一般进行强制类型转换的时候，会检查是都存在valueOf的方法，如果存在的话，使用这个方法进行强制类型转换，但是如果不存在的话，就使用toString()的方法进行强制类型转换，如果这两种方法都不存在的话，就会显示TypeError。 ToBoolean在JavaScript的世界中，true和false并不等价于1和0,虽然有的时候我们进行强制类型转换的时候，结果的确是这样的，但是事实上，他们并不是一回事。 假值（false）我们看一下其他类型的值是如何被强制转换成布尔值的。 undefined null false +0 -0 和NaN “” 在逻辑上面看，除了这些的值都应该是真值，但是JavaScript规范对此并没有明确的定义，只是给出了一些示例 真值（true）这个部分比较简单，我们直接看一下下面的代码： 12345678910111213var a = 'false';var b = '0';var c = \"''\";var d = Boolean(a &amp;&amp; b &amp;&amp; c);d // truevar q = [];var w = {};var e = function(){};var r = Boolean(q &amp;&amp; w&amp;&amp; e) // true 显示类型转换我们应该更加多的使用显示类型转换，这样的话，可以避免给别人留下坑。 字符串和数字之间的显示类型转换二者之间的转换是通过String(..)和Number(..)来进行实现的，注意一下他们之前并没有new关键字，所以说并不是对对象的封装。 12345678var a = 42;var b = String(a);var c = \"3.14\";var d = Number(c);b;// \"42\"d; // 3.14 我们进行上面的转换的时候，还可以使用其他的方法来实现字符串和数字之间的显式转换： 12345678var a = 42;var b = a.toString();var c = '3.14';var d = +c;b; // \"42\"d; // 3.14 日期显式转换成数字一元运算符+的另外一个常见的用途就是将日期（Date）类型转换成时间戳的类型。 123var timestamp = +new Date();// var timeStamp = (new Date()).getTime();// var timeStamp = (new Date).getTime(); 奇特的~运算符还有一个被忽视的地方就是~运算符相关的强制类型转换，这个很让人费解，我们仔细看一下这个运算符的相关的强制类型转换吧！ ~返回的是2的补码 1~42; // -（42+1）=-43 在-（x+1）中唯一能得到0的值就是-1，也就是说当x为-1的时候。~和一些数字值在一起回返回假值0，其他的情况都会返回真值。 -1是一个“哨位值”，哨位值是在各个类型中被赋予特殊含义的值，在的应用场景中，主要是将和indexOf(..)配合使用，如果indexOf()返回为-1，将其转换成假值0，其他情况转换成真值。 对数字的解析12345678var a = \"42\";var b = \"42px\";Number(a); // 42ParseInt(a) ; // 42Number(b) ; // NaNParseInt(b) ; // 42 解析：允许字符串含有非数字的字符串，解析按照从左到右的顺序，如果遇到非数值就会停止（ParseInt）转换：不允许串非数值的字符，否则就会失败并返回NaN关系：二者的关系不是相互替代的关系，他们虽然类似，但还是各有各的用途，如果字符串在右边的非数字字符串是不影响结果的，就可以使用解析，但是如果要求字符串都必须是数字的话，就不可以使用解析啦。 ParseInt()接受的参数仅仅限于是字符串，传入数字或是其他类型的参数是没有用的，比如true，function()和[1,2,3] 我们在使用JavaScript的时候，应该尽力的杜绝隐式类型转换，这样的话，会提高错误率，比如说我们在使用三目运算符的时候。 字符串和数字对+运算符的使用，我们有的时候使用的加法，有的时候使用的拼接的方法，我们看一下下面的实例： 123456789101112var a = \"42\"var b = \"0\"var c = 42;var d = 0;a + b //\"420\"c + d // 42;var a = [1,2];var d = [3,4];a + b ; // \"1,23,4\" 布尔值的隐式转换(1)if(..)语句中的条件判断表达式(2)for(..;..;..)语句中的条件判断的第二个表达式(3)while(..)和do.. while(..)循环中的条件判断表达式(4)?:中的条件判断表达式(5)逻辑运算符||和&amp;&amp; 左边的操作数 &amp;&amp;和||在JavaScript中，&amp;&amp;和|| 并不是和其他语言一样值单纯的逻辑运算符号。&amp;&amp; 和||运算符的返回值不一定是布尔类型，而是两个操作数其中一个的值。 123456789var a = 42;var b = 'abc';var c = null;a || b // 42a &amp;&amp; b // 'abc'c || b // 'abc'c &amp;&amp; b // null || 和 &amp;&amp; 首先对第一个操作数执行条件判断，如果不是布尔值。先进行ToBoolean的强制类型转换，然后在执行条件判断 || ：如果返回结果为true ，就返回第一个操作数的值，如果为false就返回第二个操作数的值 &amp;&amp; ：如果返回结果为true ，就返回第二个操作数的值，如果为false就返回第一个操作数的值 提前使用变量ES6 规范定义了一个新的概念叫做TDZ(暂时性死区)TDZ:由于代码中的变量没有初始化而不能被引用的情况~ 1234{ a = 2; let a; // ReferenceError !} a = 2 试图在let a 初始化a之前使用该变量，这就是a的暂时性死区，会产生错误","link":"/2019/07/11/强制类型转换/"},{"title":"样式编程规范","text":"1.命名规范（1）在js中，变量的命名方式：驼峰式命名。例如：myCoin（2）对于文件夹的命名：my_list_work（3）对于css中类的命名：my-style（4）对于函数的命名:驼峰式命名。例如：myCoin()（5）变量的命名要有意义 2.注释的写法（1）在js中，段注释采用 :/**/（2）在js中，单段的注释使用：//（3）在js中，统一使用单引号（4）html中，为某一个成块的div添加注释（5）在css中，可以标识该css，主要针对的是哪一个组件，减少使用！important、 （6）在CSS中，统一使用双引号 对于代码进行精简重构 4.对于CSS的编码要求（1）颜色编写统一采用十六进制小写的形式：#ffffff或#fff 5.对于HTML的编码要求（1）html中尽量少些内联的样式，抽成class提出来 6.对于JavaScript的编码要求（1）如果使用jquery动态操作DOM节点，最好把这部分样式抽取出，放在额外的一个专门管理样式的文件中。（2）尽可能使用箭头函数。","link":"/2020/11/01/样式编程规范/"},{"title":"浅谈前端的异步","text":"背景其实对于JavaScript语言来说，执行环境是单线程的，也就是说一次只能完成一个任务，当有多个任务的时候，需要排队一个个的实现，换言之，就是前一个任务执行完成了，才会执行后面的任务。这样的执行环境很简单，也比较单纯，但是也存在一定的问题，那就是当我们有的任务执行的时候比较耗时的时候，我需要执行完整个耗时的任务，才可以开始执行下面的任务，这样就有可能造成阻塞的现象，对于前端来说常见的就是浏览器无响应（假死），也就是 js 的执行时间比较长，导致页面卡死在某一个地方，其他的任务是无法正常的执行的。这个时候，即使我们进行界面的刷新，也不能解决上面的问题，造成用户体验差。 为了避免和解决这个问题，js 语言将任务执行模式分为同步和异步。同步模式：等待前一个任务执行完成，在执行下一个任务，任务是依次进行执行的异步模式：每一个任务都有一个或是多个回调函数（callback），前一个任务执行结束之后，并不是执行后面的任务，而是执行回调函数，后面的任务执行也不是等前一个任务执行完成，而是和前一个任务几乎是并行的，所以程序的执行顺序和任务的排列顺序是不一致的，异步的。 回调函数这份事故异步编程最基本的方法，我们首先从概念的角度了解一下，什么叫回调函数：回调函数的英文定义：A callback is a function that is passed as an argument to another function and is executed after its parent function has completed。上面的英文很清楚的看出什么是回调函数：回调函数本质上就是一个参数，将一个行数作为参数传递到另外一个函数中，当另外一个行数执行完成，在执行传进去的这个函数，这个过程就是回调。可能比较晦涩，现在我们用 js 语言进行举例：函数 A 作为参数（函数引用）传递到另外一个函数 B 中，并且这个函数 B 执行函数 A，那么 A 就叫做回调函数，如果 A 是没有名字的函数，那么就叫匿名回调函数。我们也可以举一个生活中的例子：春节放假结束的时候，你和你的父母离别的时候，你父母和你说 “到单位了打一个电话，我们很担心你”，然后你到单位了就给你的父母发了一条短信。这就是一个回调的过程。你的父母留了一个参数函数（要求你打电话）给你，然后你到单位，到单位就是主函数，必须要到单位之后，主函数执行完成之后，再执行传进去的函数，然后你的父母就收到了一条短信。 我们如果从代码的角度进行描述，假设现在 f1()和 f2()的两个函数，如果什么都不操作： 123456const f1 = ()= {...}const f2 = ()= {...}const test =()=&gt;{ f1(); f2();} 上面的执行很显然结果是f2()要等待f1()执行完成之后才可以继续执行，如果f1()是一个很耗时的行数，就会导致程序的阻塞，这个时候我们可以将上面的函数改成回调行数的形式. 1function f1(callback){setTimeout (function(){ f1的任务代码callback();},1000)}) 执行代码就变成下面这样： 1f1(f2); 采用这样的方式，我们将同步的操作变成了异步的操作，这样的话不会因为f1()执行缓慢进而阻塞了程序，相当于先执行程序的主要逻辑，将耗时的操作进行可推迟。我们可以从另外一个例子 12345678910111213141516// 定义主函数，回调行数最为参数A = (callback) =&gt;{ callback(); console.log(&quot;我是主函数&quot;)}// 定义回调行数，也就是当做参数的函数B=()=&gt;{ setTimeout(&quot;console.log(&apos;我是回调行数&apos;)&quot;,3000) // 用来模仿一个很耗时的操作}A(B) // 调用主函数,将函数B传进去// 输出的结果我是主函数我是回调函数} 我们分析一下上面的代码，我们让代码先去执行callback()的回调函数，但是输出的结果却是先输出了主函数的语句，后输出回调函数的语句。这就说明了。主函数不用等待回调行数执行完，可以接着执行自己的代码。根据上面的代码我们看到了我们一般讲比较耗时的操作用作回调行数。从上面我们看到了一个回调是否是异步的主要取决于传输的参数的函数是都是异步的。 ps：setTimeout、setInterval 的函数调用得到其返回值，由于两个行数都是异步的，即：他们的调用时序和主流程序是相对独立的，所以没有办法在主体函数中获取他们的返回值，他们被打开的时候，程序也不会停下来等待，否则也就失去了setTimeout、以及setInterval的意义了，所以用return是没有意义的，只能使用callback，callback的意义在于将 timer 执行的结果通知给代理函数进行及时处理。 回调函数这种方式的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合“，有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。","link":"/2020/11/01/浅谈前端异步/"},{"title":"特蕾莎修女的诗歌《无论如何》","text":"如果你做善事，人们说你自私自利、别有用心，不管怎样，还是要做善事； 如果你成功以后，身边尽是假的朋友和真的敌人，不管怎样，还是要成功； 你所做的善事明天就会被遗忘，不管怎样，还是要做善事； 诚实与坦率使你容易受到欺骗和伤害，不管怎样，还是要诚实与坦率； 人都会同情弱者，却只追随赢家，不管怎样，还是要为一些弱者奋斗； 你耗费数年所建设的可能毁于一旦，不管怎样，还是要建设； 如果你找到了平静和幸福，人们可能会嫉妒你，不管怎样，还是要快乐； 人们确实需要帮助，然而如果你帮助他们，却可能遭到攻击，不管怎样，还是要帮助； 将你所拥有最好的东西献给世界，可能永远都不够，不管怎样，还是要将最好的东西付出！ 你看，说到底，它是你和上帝之间的事，而决不是你和他人之间的事。","link":"/2020/11/01/特蕾莎修女的诗歌-无论如何/"},{"title":"虚拟Dom与Diff算法","text":"在react框架中，采用虚拟dom,我们可以不用担心性能问题而随时随地的进行整个界面的刷新。由虚拟DOM来确认当界面真正发生变化的时候，只对需要变化的局部的DOM进行操作。 什么是 DOM Diff 算法当web的某一个部分发生变化的时候，就是对应的DOM节点发生了变化，由react来比较两个界面的区别，这就需要对于DOM树进行Diff算法的分析。对于标准的Diff算法的复杂度是O(n^3)，这样的复杂度是没有办法满足性能上的要求，如果每一次的界面都可以整体刷新界面的目的，我们一定要对Diff算法进行优化，他们基于web界面的特点做了两个简单的假设，使得Diff算法的复杂度直接的降低到了O(n) 两个相同组件产生类似的DOM结构，不同的组件产生DOM结构 对于同一层次的一组子节点，可以通过id进行区分。 算法上的优化是React整个界面的Render的基础，事实上也证明这两个假设是合理而且精确的，保证了整体界面构建的性能。 不同节点类型的比较在react中比较两个虚拟DOM节点，当两个节点不同的时候，应该如何进行处理，主要分成两种情况：(1)节点类型不同(2)节点类型相同，但是属性不同 当在树的同一个位置前后输出不同类型的界面，react的具体操作是直接删除前面的节点，然后创建并插入新的节点，我们下面看一个具体的例子： 123renderA: &lt;div /&gt;renderB: &lt;span /&gt;=&gt; [removeNode &lt;div /&gt;], [insertNode &lt;span /&gt;] 简单来说就是先将A节点删除掉，然后插入B节点，在这个构成中我们需要注意的是：删除节点意味着彻底的销毁了这个节点，而不是在后续的比较中看是否有另外一个节点等于改删除的节点，如果被删除的节点有子节点的话，那么子节点也会被删除，不会在后面的继续比较，这也是复杂度降低的主要原因。上面提到的是对虚拟DOM节点的操作，而同样的逻辑也被用在React组件的比较。 123renderA: &lt;Header /&gt;renderB: &lt;Content /&gt;=&gt; [removeNode &lt;Header /&gt;], [insertNode &lt;Content /&gt;] React 在同一个位置遇到不同的组件时，也是简单的销毁第一个组件，而把新创建的组件加上去。这正是应用了第一个假设，不同的组件一般会产生不一样的 DOM 结构，与其浪费时间去比较它们基本上不会等价的 DOM 结构，还不如完全创建一个新的组件加上去,将大量的比较时间节省了时间，通过时间我们发现 React的 DOM Diff算法实际上只会对树进行逐层比较： 逐层进行节点比较而在 React 中，树的算法其实非常简单，那就是两棵树只会对同一层次的节点进行比较。如下图所示： React 只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。 上面的过程就是现将A节点以及A的子节点都删除，然后将重新创造一个上面的结构，然后将这个结构整体挂到D的后面。因为React 只会简单的考虑同层节点的位置变换，对于不同层的节点，只有简单的创建和删除。当根节点发现子节点中A 不见了，就会直接销毁A；而当D发现自己多了一个子节点A，则会创建一个新的A作为子节点。因此对于这种结构的转变的实际操作是： 12345A.destroy();A = new A();A.append(new B());A.append(new C());D.append(A); 由 DOM Diff 算法理解组件的生命周期我们再来看一下React的生命周期，其中的每一个阶段其实都和DOM Diff算法是息息相关的： constructor: 构造函数，组件被创建时执行； componentDidMount: 当组件添加到 DOM 树之后执行； componentWillUnmount: 当组件从DOM 树中移除之后执行，在 React 中可以认为组件被销毁； componentDidUpdate: 当组件更新时执行。相同类型节点的比较第二种节点的比较是相同类型的节点，算法就相对简单而容易理解。React 会对属性进行重设从而实现节点的转换。例如:123renderA: &lt;div id=&quot;before&quot; /&gt;renderB: &lt;div id=&quot;after&quot; /&gt;=&gt; [replaceAttribute id &quot;after&quot;] 虚拟DOM的style属性稍有不同，其值并不是一个简单字符串而必须为一个对象，因此转换过程如下： 123renderA: &lt;div style={{color: &apos;red&apos;}} /&gt;renderB: &lt;div style={{fontWeight: &apos;bold&apos;}} /&gt;=&gt; [removeStyle color], [addStyle font-weight &apos;bold&apos;] 列表节点的比较上面介绍了对于不在同一层的节点的比较，即使它们完全一样，也会销毁并重新创建。那么当它们在同一层时，又是如何处理的呢？React 在遇到列表时却又找不到key 时提示的警告。虽然无视这条警告大部分界面也会正确工作，但这通常意味着潜在的性能问题。因为 React 觉得自己可能无法高效的去更新这个列表。我们可以从一个例子看一下这个问题： 当我们没有为每一个节点设置唯一标识的时候，React 无法识别每一个节点，那么更新过程会很低效，即，将 C 更新成 F，D更新成 C，E 更新成D，最后再插入一个E 节点。效果如下图所示： React会逐个对节点进行更新，转换到目标节点。而最后插入新的节点E，涉及到的 DOM 操作非常多。而如果给每个节点唯一的标识（key），那么 React能够找到正确的位置去插入新的节点，入下图所示： 结束语本文分析了 React 的 DOM Diff 算法究竟是如何工作的，其复杂度控制在了O（n），这让我们考虑 UI 时可以完全基于状态来每次render整个界面而无需担心性能问题，简化了 UI 开发的复杂度。而算法优化的基础是文章开头提到的两个假设，以及 React的UI基于组件这样的一个机制。理解虚拟 DOM Diff 算法不仅能够帮助我们理解组件的生命周期，而且也对我们实现自定义组件时如何进一步优化性能具有指导意义。","link":"/2020/11/01/虚拟Dom与Diff算法/"},{"title":"查找算法","text":"什么是二分查找算法，输入一个有序的元素列表（这个是必要条件），若要查找的元素包含在列表中，二分查找返回其位置，否则就返回null 获取字符串长度（英文占一个字符，中文两个字符）使用方法，传入一个字符串，返回这个字符串的长度，其中英文占一个字符，中文两个字符。 12345678910111213141516const bytesCount = str =&gt;{ if(str !== null &amp;&amp; str !== undefined){ let bCount = 0; for(let i = 0; i&lt;str.length;i++){ const c = str.charAt(i); const flag = /^[\\u0020-\\uooff]$/.test(c); if(flag){ bCount+ =1; }else{ bCount+ =2; } } return bCount; }}; 单位转换（将B转换成合适的单位 如KB、MB…） 进行单位转换，其中用到了lodash中的findIndex()方法 123456789101112131415161718/* * @param{*} bytes 传入具体的值，也就是将要进行转换的值* @param{*} number 传入具体的值的单位* 返回一个结果数组[6,'M'] 返回一个数组，第一位是值，第二位是单位*/import {findIndex} from 'lodash';const tranformBytes =(bytes,{minUnit = 'B'}={})=&gt;{ const units =['B','KB','MB','GB','TB','PB']; // 单位的合集 const minUnitIndex = findIndex(units,value=&gt;value=== minUnit); // 最小的显示单位 let index; // 下标 用来计算合适单位的下标 for(index = minUnitIndex ;index &lt;= units.length;index++){ if(index === units.length || bytes &lt; Math.pow(1024,index+1) ){ break; } } return [bytes / Math.pow(1024,index+1),units[index]];}","link":"/2023/10/28/查找算法/"}],"tags":[{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"异步","slug":"异步","link":"/tags/异步/"},{"name":"安全","slug":"安全","link":"/tags/安全/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"基础","slug":"基础","link":"/tags/基础/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"数组","slug":"数组","link":"/tags/数组/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"栈","slug":"栈","link":"/tags/栈/"},{"name":"工具","slug":"工具","link":"/tags/工具/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"语言","slug":"语言","link":"/tags/语言/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"antDesign","slug":"antDesign","link":"/tags/antDesign/"},{"name":"表格","slug":"表格","link":"/tags/表格/"},{"name":"antdsign","slug":"antdsign","link":"/tags/antdsign/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"less","slug":"less","link":"/tags/less/"},{"name":"样式","slug":"样式","link":"/tags/样式/"},{"name":"moment","slug":"moment","link":"/tags/moment/"},{"name":"组件","slug":"组件","link":"/tags/组件/"},{"name":"渲染","slug":"渲染","link":"/tags/渲染/"},{"name":"state","slug":"state","link":"/tags/state/"},{"name":"axios","slug":"axios","link":"/tags/axios/"},{"name":"redux","slug":"redux","link":"/tags/redux/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"实践","slug":"实践","link":"/tags/实践/"},{"name":"webPack","slug":"webPack","link":"/tags/webPack/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"面试ES6基础","slug":"面试ES6基础","link":"/tags/面试ES6基础/"},{"name":"echarts","slug":"echarts","link":"/tags/echarts/"},{"name":"map坐标","slug":"map坐标","link":"/tags/map坐标/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"规范","slug":"规范","link":"/tags/规范/"},{"name":"编程规范","slug":"编程规范","link":"/tags/编程规范/"},{"name":"小文章","slug":"小文章","link":"/tags/小文章/"},{"name":"基础认知","slug":"基础认知","link":"/tags/基础认知/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"前端1","slug":"前端1","link":"/tags/前端1/"},{"name":"JavaScript1","slug":"JavaScript1","link":"/tags/JavaScript1/"}],"categories":[{"name":"前端异步","slug":"前端异步","link":"/categories/前端异步/"},{"name":"安全","slug":"安全","link":"/categories/安全/"},{"name":"重学前端","slug":"重学前端","link":"/categories/重学前端/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"},{"name":"工具","slug":"工具","link":"/categories/工具/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"前端编程语言","slug":"前端编程语言","link":"/categories/前端编程语言/"},{"name":"前端功能实现代码","slug":"前端功能实现代码","link":"/categories/前端功能实现代码/"},{"name":"性能","slug":"性能","link":"/categories/性能/"},{"name":"less","slug":"less","link":"/categories/less/"},{"name":"redux","slug":"redux","link":"/categories/redux/"},{"name":"webPack","slug":"webPack","link":"/categories/webPack/"},{"name":"公共方法","slug":"公共方法","link":"/categories/公共方法/"},{"name":"面试","slug":"面试","link":"/categories/面试/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"小文章","slug":"小文章","link":"/categories/小文章/"},{"name":"算法","slug":"算法","link":"/categories/算法/"}]}